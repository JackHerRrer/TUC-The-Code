include("GlobalVar");
include("util_combos");

/********************************************************************************************/


function getDamage(ID, strength) {	
	var damage = [];
	
	if(isChip(ID)) {
	
		var chipEffects = getChipEffects(ID);
		
		for (var chipEffect in chipEffects) {
			if(chipEffect[0] == EFFECT_DAMAGE) {
				var chipDamage = [];
				damage["MIN"] = chipEffect[1] * (1+strength/100);
				damage["MAX"] = chipEffect[2] * (1+strength/100);
				//push(damage, chipDamage);
			}
		}
	} else if (isWeapon(ID)) {
		var weaponEffects = getWeaponEffects(ID);
		
		for (var weaponEffect in weaponEffects) {
			if(weaponEffect[0] == EFFECT_DAMAGE) {
				var weaponDamage = [];
				damage["MIN"] = weaponEffect[1] * (1+strength/100);
				damage["MAX"] = weaponEffect[2] * (1+strength/100);
				//push(damage, weaponDamage);
			}	
		}
	} else {
		debug("Ni puce ni arme !!");
	}
	return damage;
}

/********************************************************************************************/
// function used to return the average armor buff of a skill 
function getArmorBuff(ID, resistance) {	
	var averageDamage = 0;

	if(isChip(ID)) {
	
		var chipEffect = getChipEffects(ID);
		
		if(chipEffect[0][0] == EFFECT_ABSOLUTE_SHIELD || chipEffect[0][0] == EFFECT_RELATIVE_SHIELD){
			averageDamage = ((chipEffect[0][2] * (1+resistance/100))+(chipEffect[0][2] * (1+resistance/100)))/2;
		}
	} else {
		debug("getArmorBuff: Not a chip");
	}
	return averageDamage;
}

/******************************************************************************************/
// Fonction used to calculate the average damage of a skill
// every parameters are managed
// except poison: to be improved
function calculateDamage(userStrenght, targetCell, targetRelativeShield, targetAbsoluteShield, objectID, cellID) {	

	var area;
	if(isWeapon(objectID)) {
		area = getWeaponArea(objectID);
	}
	else if(isChip(objectID)) {
		area = getChipArea(objectID);
	}

	if (area != null){
		var zoneMaxExtent;
		if (area == AREA_CIRCLE_1){
			zoneMaxExtent = 1;
		}
		else if (area == AREA_CIRCLE_2){
			zoneMaxExtent = 2;
		}
		else if (area == AREA_CIRCLE_3){
			zoneMaxExtent = 3;
		}
		else {
			//VÃ©rifier que la condition est vrai dans le cas du laser
			if (getCellDistance(cellID, targetCell)){
				debug("The object wont hit the target");	
				return null;	
			}
			zoneMaxExtent = 1;

		}
		var ratioDistance = 1 - (getCellDistance(cellID, targetCell) / zoneMaxExtent * 0.5);
		var damage = getDamage(objectID, userStrenght);
		if (damage == null){
			debug ("damage is null");
			return null;
		}

		// calculate the average damage. If the result is inferior to 0, then 0 is returned 
		return max(0, (damage["MAX"] + damage["MIN"])/2 * ratioDistance * (1 - targetRelativeShield / 100) - targetAbsoluteShield);
	}
	else {
		debug("Area is null");
		return null;
	}
}

/******************************************************************************************/
// stub score function. Used whenever the score function of a skill has not been implemented yet.
function default_score_function(){

	//var skill = analyzedTrajectory[skillKey][SKILL];
	return 0;
}

/******************************************************************************************/
// Gather the caracteristics of leekId and store them leekCarac
// TO BE COMPLETED
function getLeekCarac(leekId){

	var leekCarac = [];

	leekCarac[CELL] = 				getCell(leekId);
	leekCarac[STRENGTH] = 			getStrength(leekId);
	leekCarac[LIFE] = 				getLife(leekId);
	leekCarac[RELATIVE_SHIELD] = 	getRelativeShield(leekId);
	leekCarac[ABSOLUTE_SHIELD] = 	getAbsoluteShield(leekId);
	leekCarac[SCIENCE] = 			getScience(leekId);
	leekCarac[AGILITY] = 			getAgility(leekId);
	leekCarac[MP] = 				getMP(leekId);
	leekCarac[TP] = 				getTP(leekId);
	leekCarac[RESISTANCE] = 		getResistance(leekId);

	return leekCarac;
}


/******************************************************************************************/

function damage_score_function(){

	// retrieve the information associated to the skill being analyzed
	var skill = analyzedTrajectory[SKILL][skillKey];
	if (skill === null){
		debugE("damage_score_function: skill is null");
		return 0;
	}
	
	// If the current combo
	if (isCombo == true){
		// calculateDamage return the average damage value, not the exact value.
		return calculateDamage(ourLeekCaracTemp[STRENGTH], enemyLeekCaracTemp[CELL], enemyLeekCaracTemp[RELATIVE_SHIELD], enemyLeekCaracTemp[ABSOLUTE_SHIELD], skill, enemyLeekCaracTemp[CELL]);
	}
	else {
		return calculateDamage(ourLeekCaracTemp[STRENGTH], analyzedTrajectory[TARGET_CELL][skillKey], enemyLeekCaracTemp[RELATIVE_SHIELD], enemyLeekCaracTemp[ABSOLUTE_SHIELD], skill, enemyLeekCaracTemp[CELL]);
	}
}


/******************************************************************************************/

function armor_score_function(){

	// retrieve the information associated to the skill being analyzed
	var skill = analyzedTrajectory[SKILL][skillKey];
	if (skill === null){
		debugE("damage_score_function: skill is null");
		return 0;
	}

	var effects = getChipEffects(skill);
	if (effects[0][0] == EFFECT_RELATIVE_SHIELD){
		ourLeekCaracTemp[RELATIVE_SHIELD] = getArmorBuff(skill, ourLeekCaracTemp[RESISTANCE]);
	}
	else if (effects[0][0] == EFFECT_ABSOLUTE_SHIELD){		
		ourLeekCaracTemp[ABSOLUTE_SHIELD] = getArmorBuff(skill, ourLeekCaracTemp[RESISTANCE]);
	}
	else debug("armor score function error");
	
	return 0;
}

/*******************************************************************************************/

function buff_score_function(){

	// retrieve the information associated to the skill being analyzed
	var skill = analyzedTrajectory[SKILL][skillKey];
	if (skill === null){
		debugE("damage_score_function: skill is null");
		return 0;
	}

	var effects;
	effects = getChipEffects(skill);

	var boostFinal;
	boostFinal = (effects[0][1] + effects[0][2])/2 * (1 + ourLeekCaracTemp[SCIENCE] / 100);

	if (effects[0][0] == EFFECT_BUFF_FORCE){
		ourLeekCaracTemp[STRENGTH] += boostFinal;
	}
	else if (effects[0][0] == EFFECT_BUFF_AGILITY){
		ourLeekCaracTemp[AGILITY] += boostFinal;
	}
	else if (effects[0][0] == EFFECT_BUFF_MP){
		ourLeekCaracTemp[MP] += boostFinal;
	}
	else if (effects[0][0] == EFFECT_BUFF_RESISTANCE){
		ourLeekCaracTemp[RESISTANCE] += boostFinal;
	}
	else if (effects[0][0] == EFFECT_BUFF_TP){
		ourLeekCaracTemp[TP] += boostFinal;
	}
	else{

		debugE("buffScorefunction error: skill: " + skill + " effect: " + effects[0]);
	}
	return 0;
}

// function used to calculate the score of the cell postion (to be improved)
//  * doesn't handle indirect hit
//  * approximate the damages: only takes the highest damage skill once

function calculatePositionScore(cell){
	
	var highestDamage = 0;
	 
	for (var skill in dangerMap[cell]){
		var damage = calculateDamage(ourLeekCaracTemp[STRENGTH], cell, ourLeekCaracTemp[RELATIVE_SHIELD], ourLeekCaracTemp[ABSOLUTE_SHIELD], skill["OBJECT_ID"], cell);
		if (damage > highestDamage){
			highestDamage = damage;
		}
	}

	return -highestDamage;
}