include("GlobalVar");
include("util_can_use");
include("Strategy");
include("util_combos");
include("IA_main");

function initGameFunction(){
	//debug("init game state");

    ourLeekID = getLeek();

    generateGroundScoreMap();

	etat = INIT_TURN;
}

function initTurnFunction(){
	//debug("init turn state");	

	//raz de la liste des actions à effectuer
	actionSequence = [];
	currentAction = 0;
	actionTotal = 0;
	TPTotal = 0;
	MPTotal = 0;

	// raz des différentes cartes
	actionMap = [];
	dangerMap = [];
	movingArea = [];

	actionNodes = [];
	dangerNodes = [];
	safeNodes = [];
	
	processedActions = [];
	
	// raz des donnés de combo
	skillsCostList = [];
	costCombosList = [];
	skillSortedByCosts = [];
	combosList = [];
	sortedCombosList = [];
	filteredCombosList = [];
	comboScores = [];
	sortedComboScores = [];
	nbComboUsed = 0;
	allTrajectories = [];
	trajectories = [];
	bestTrajectoryKey = null;

	// raz des carac des leeks
	ourLeekCarac = [];
	enemyLeekCarac = [];
	ourLeekCaracTemp = [];
	enemyLeekCaracTemp = [];

	// raz des variables and signals used to calculate the scores
	isCombo = true;
	skillKey = 0;
	analyzedTrajectory = [];
		analyzedTrajectory[SKILL] = [];
		analyzedTrajectory[CELLS] = [];
		analyzedTrajectory[MVMP] = [];
		analyzedTrajectory[TARGET_CELL] = [];
		analyzedTrajectory[SCORE] = [];
		analyzedTrajectory[TOTAL_SCORE] = 0;


	// Choose the closest leek enemy (not a bulb)
	// TO BE IMPROVED
	if (getType() == ENTITY_LEEK) {
		var enemyList = getAliveEnemies();
		var distToNearestEnenmy = 1000;
		for (var i = 0; i < count(enemyList); i++){
			if (getType(enemyList[i]) == ENTITY_LEEK){
				var distToEnemy = getPathLength(getCell(ourLeekID), getCell(enemyList[i]));
				if (distToEnemy < distToNearestEnenmy){
					enemyID = enemyList[i];
					distToNearestEnenmy = distToEnemy;
				}
			}
		}
	}
	else{
		enemyID = getNearestEnemy();
	}

	if (enemyID == null){
		debug("no enemy selected");
		enemyID = getNearestEnemy();
	}

	etat = STRATEGY_CHOICE;
}

function strategyChoiceFunction(){
	//debug("strategy choice state"); 

	if (getType() == ENTITY_LEEK || getType() == ENTITY_BULB ){
		leekStrategyChoice();
	}
	else {
		punnyBulbStrategyChoice();
	}

	// display the list of the chosen actions
	debug("******************************");
	for (var i = 0; i < actionTotal; i++){
		if (actionSequence[i][0] == USE_OBJECT){
			debug(actionSequence[i][0] + " : " + getSkillName(actionSequence[i][1]));
		}
		else if (actionSequence[i][0] == MOVE_TO_CELL){
			debug(actionSequence[i][0] + " : " + actionSequence[i][1]);
		}
		else {
			debug(actionSequence[i][0]);			
		}
	}
	debug("TP total : "+ TPTotal);
	debug("******************************\n");

	etat = ACTION_CHOICE;	
}

function actionChoiceFunction(){
	//debug("action choice state"); 

	if (currentAction < actionTotal){
		etat = actionSequence[currentAction][0];		
		// As currentAction is incremented before the action happens, to get the right parameters of the action, currentAction - 1 needs to be used
		currentAction++;
	}
	else {
		etat = LAST_ACTION;
	}
	
}

function summonLightningBulbFunction(){
	debug("summon lightnong bulb state"); 	
	
	if (getType() == ENTITY_LEEK){
		var summoningCell = getCell();
		moveAwayFrom(enemyID, 2);
		debug("summon result: " +summon(CHIP_LIGHTNING_BULB, summoningCell, stateMachine));
	}
	else{
		moveToward(enemyID);
	}

	etat = ACTION_CHOICE;
}


function summonFireBulbFunction(){
	debug("summon fire bulb state"); 	
	
	if (getType() == ENTITY_LEEK){
		var summoningCell = getCell();
		moveAwayFrom(enemyID, 2);
		debug("summon result: " +summon(CHIP_FIRE_BULB, summoningCell, stateMachine));
	}
	else{
		moveToward(enemyID);
	}

	etat = ACTION_CHOICE;
}

function summonPunnyBulbFunction(){
	debug("summon punny bulb state"); 	
	
	var summoningCell = getCell();
	moveToward(enemyID, 1);
	summon(CHIP_PUNY_BULB, summoningCell, stateMachine);

	etat = ACTION_CHOICE;
}


function useObjectFunction(){
	// Parameters of this state
	// actionSequence[0][0] =  USE_OBJECT;
	// actionSequence[0][1] =  object_ID; 
	// actionSequence[0][2] =  targetCell;

	debug("use object state : " + getSkillName(actionSequence[currentAction - 1][1]));

	// if the current action is a weapon then use the weapon
	if (isWeapon(actionSequence[currentAction - 1][1])){
		useWeaponOnCell(actionSequence[currentAction - 1][2]);
	} 
	// if the current action is a chip then use the chip
	else if (isChip(actionSequence[currentAction - 1][1])){
		// if the current chip is a summoning, then summon it
		if (actionSequence[currentAction - 1][1] == CHIP_FIRE_BULB || 
			actionSequence[currentAction - 1][1] == CHIP_HEALER_BULB ||
			actionSequence[currentAction - 1][1] == CHIP_ICED_BULB ||
			actionSequence[currentAction - 1][1] == CHIP_LIGHTNING_BULB ||
			actionSequence[currentAction - 1][1] == CHIP_METALLIC_BULB ||
			actionSequence[currentAction - 1][1] == CHIP_PUNY_BULB ||
			actionSequence[currentAction - 1][1] == CHIP_PUNY_BULB
			){
			summon(actionSequence[currentAction - 1][1], actionSequence[currentAction - 1][2], stateMachine);
		}
		// otherwise, simply use the chip
		else{
			useChipOnCell(actionSequence[currentAction - 1][1], actionSequence[currentAction - 1][2]);
		}	
	}
	else{
		debug("error : this is not an object");
	}

	etat = ACTION_CHOICE;
}

function moveToCellFunction(){
	// Parameters of this state
	// actionSequence[0][0] =  MOVE_TO_CELL;
	// actionSequence[0][1] =  cell; 
	
	debug("Move to cell state : " + actionSequence[currentAction - 1][1]);
	moveTowardCell(actionSequence[currentAction - 1][1]);

	etat = ACTION_CHOICE;
}

function equipWeaponFunction(){
	// Parameters of this state
	// actionSequence[0][0] =  EQUIP_WEAPON;
	// actionSequence[0][1] =  weaponID; 
	
	debug("Equip weapon state : ");
	setWeapon(actionSequence[currentAction - 1][1]); // Attention : coûte 1 PT
	weaponID = getWeapon();

	etat = ACTION_CHOICE;
}

function lastActionFunction() {

	debug("Total operation : " + prettyPrintNb(getOperations()));
	debug("remaining operation : " + prettyPrintNb(OPERATIONS_LIMIT - getOperations()));
	debug("remaining TP: " + getTP());

	if (isDead(enemyID)){say ("Reviens gamin !! C'était pour rire ");}
	else if (getTurn() == 2){
		if (getType() == ENTITY_LEEK){
			say("Une larme de gin. Une rivière de tonic... Et ensuite la p'tite victime");
		}
		else {
			say("Pigeon, oiseau à la grise robe,\ndans l'enfer des villes, à mon regard tu te dérobes...\nTu es vraiment le plus agile. ");
		}
	}

	etat = END_TURN;
}

