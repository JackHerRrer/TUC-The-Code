include("GlobalVar");
include("util_can_use");
include("Strategy");
include("util_combos");
include("IA_main");

function initGameFunction(){
	//debug("init game state");

    ourLeekID = getLeek();

	etat = INIT_TURN;
}

function initTurnFunction(){
	//debug("init turn state");	

	//raz de la liste des actions à effectuer
	actionSequence = [];
	currentAction = 0;
	actionTotal = 0;
	TPTotal = 0;
	MPTotal = 0;

	// raz des différentes cartes
	actionMap = [];
	dangerMap = [];
	movingArea = [];

	actionNodes = [];
	dangerNodes = [];
	safeNodes = [];

	// raz des donnés de combo
	skillsCostList = [];
	costCombosList = [];
	skillSortedByCosts = [];
	combosList = [];
	sortedCombosList = [];
	filteredCombosList = [];
	comboScores = [];
	sortedComboScores = [];
	allTrajectories = [];
	trajectories = [];
	bestTrajectoryKey = null;

	// raz des carac des leeks
	ourLeekCarac = [];
	enemyLeekCarac = [];
	ourLeekCaracTemp = [];
	enemyLeekCaracTemp = [];
	
	// Choose the closest leek enemy (not a bulb)
	// TO BE IMPROVED
	var enemyList = getAliveEnemies();
	var distToNearestEnenmy = 1000;
	for (var i = 0; i < count(enemyList); i++){
		if (getType(enemyList[i]) == ENTITY_LEEK){
			var distToEnemy = getPathLength(getCell(ourLeekID), getCell(enemyList[i]));
			if (distToEnemy < distToNearestEnenmy){
				enemyID = enemyList[i];
				distToNearestEnenmy = distToEnemy;
			}
		}
	}

	if (enemyID == null){
		debug("no enemy selected");
		enemyID = getNearestEnemy();
	}

	etat = STRATEGY_CHOICE;
}

function strategyChoiceFunction(){
	//debug("strategy choice state"); 

	if (getType() == ENTITY_LEEK){
		leekStrategyChoice();
	}
	else {
		punnyBulbStrategyChoice();
	}

	// display the list of the chosen actions
	debug("******************************");
	for (var i = 0; i < actionTotal; i++){
		if (actionSequence[i][0] == USE_OBJECT){
			debug(actionSequence[i][0] + " : " + getSkillName(actionSequence[i][1]));
		}
		else if (actionSequence[i][0] == MOVE_TO_CELL){
			debug(actionSequence[i][0] + " : " + actionSequence[i][1]);
		}
		else {
			debug(actionSequence[i][0]);			
		}
	}
	debug("TP total : "+ TPTotal);
	debug("******************************\n");

	etat = ACTION_CHOICE;	
}


function actionChoiceFunction(){
	//debug("action choice state"); 

	if (currentAction < actionTotal){
		etat = actionSequence[currentAction][0];		
		// As currentAction is incremented before the action happens, to get the right parameters of the action, currentAction - 1 needs to be used
		currentAction++;
	}
	else {
		etat = LAST_ACTION;
	}
	
}


function summonPunnyBulbFunction(){
	debug("summon punny bulb state"); 	
	
	var summoningCell = getCell();
	moveToward(enemyID, 1);
	summon(CHIP_PUNY_BULB, summoningCell, stateMachine);

	etat = ACTION_CHOICE;
}


function useObjectFunction(){
	// Parameters of this state
	// actionSequence[0][0] =  USE_OBJECT;
	// actionSequence[0][1] =  object_ID; 
	// actionSequence[0][2] =  targetCell;

	debug("use object state : " + getSkillName(actionSequence[currentAction - 1][1]));

	if (isWeapon(actionSequence[currentAction - 1][1])){
		useWeaponOnCell(actionSequence[currentAction - 1][2]);
	}
	else if (isChip(actionSequence[currentAction - 1][1])){
		useChipOnCell(actionSequence[currentAction - 1][1], actionSequence[currentAction - 1][2]);
	}
	else{
		debug("error : this is not an object");
	}

	etat = ACTION_CHOICE;
}

function moveToCellFunction(){
	// Parameters of this state
	// actionSequence[0][0] =  MOVE_TO_CELL;
	// actionSequence[0][1] =  cell; 
	
	debug("Move to cell state : " + actionSequence[currentAction - 1][1]);
	moveTowardCell(actionSequence[currentAction - 1][1]);

	etat = ACTION_CHOICE;
}

function equipWeaponFunction(){
	// Parameters of this state
	// actionSequence[0][0] =  EQUIP_WEAPON;
	// actionSequence[0][1] =  weaponID; 
	
	debug("Equip weapon state : ");
	setWeapon(actionSequence[currentAction - 1][1]); // Attention : coûte 1 PT
	weaponID = getWeapon();

	etat = ACTION_CHOICE;
}

function lastActionFunction() {

	debug("Total operation : " + getOperations());
	debug("remaining operation : " + (OPERATIONS_LIMIT - getOperations()));

	if (isDead(enemyID)){say ("Reviens gamin !! C'était pour rire ");}
	else if (getTurn() == 2){
		if (getType() == ENTITY_LEEK){
			say("Une larme de gin. Une rivière de tonic... Et ensuite la p'tite victime");
		}
		else {
			say("Pigeon, oiseau à la grise robe, dans l'enfer des villes, à mon regard tu te dérobes...Tu es vraiment le plus agile. ");
		}
	}

	etat = END_TURN;
}

