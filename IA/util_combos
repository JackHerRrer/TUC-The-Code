include("GlobalVar");
include("util_misc");
include("util_filters");
include("util_score");
include("util_can_use");

global BUFF = 		"BUFF";
global ARMOR = 		"ARMOR";
global HEAL = 		"HEAL";
global DEBUFF = 	"DEBUFF";
global DAMAGE = 	"DAMAGE";
global BULB = 		"BULB";
global POISON = 	"POISON";
global UTIL = 		"UTIL"; // peut être à modifier
global REFLECT = 	"REFLECT";

global TYPE = 0;
global SCORE_FUNCTION = 1;
global NAME = 2;

global SCORE = 0;
global KEY = 1;

global SKILL = 1;
global CELLS = 2;
global MVMP = 3;
global TARGET_CELL = 4;

global skills = [];						//[To sort the combos, to calculate the score]
skills[CHIP_BURNING] =                  [DAMAGE, damage_score_function, "CHIP_BURNING"];
skills[CHIP_DEVIL_STRIKE] =             [DAMAGE, damage_score_function, "CHIP_DEVIL_STRIKE"];
skills[CHIP_FLAME] =                    [DAMAGE, damage_score_function, "CHIP_FLAME"];
skills[CHIP_FLASH] =                    [DAMAGE, damage_score_function, "CHIP_FLASH"];
skills[CHIP_ICE] =                      [DAMAGE, damage_score_function, "CHIP_ICE"];
skills[CHIP_ICEBERG] =                  [DAMAGE, damage_score_function, "CHIP_ICEBERG"];
skills[CHIP_LIGHTNING] =                [DAMAGE, damage_score_function, "CHIP_LIGHTNING"];
skills[CHIP_METEORITE] =                [DAMAGE, damage_score_function, "CHIP_METEORITE"];
skills[CHIP_PEBBLE] =                   [DAMAGE, damage_score_function, "CHIP_PEBBLE"];
skills[CHIP_ROCK] =                     [DAMAGE, damage_score_function, "CHIP_ROCK"];
skills[CHIP_ROCKFALL] =                 [DAMAGE, damage_score_function, "CHIP_ROCKFALL"];
skills[CHIP_SHOCK] =                    [DAMAGE, damage_score_function, "CHIP_SHOCK"];
skills[CHIP_SPARK] =                    [DAMAGE, damage_score_function, "CHIP_SPARK"];
skills[CHIP_STALACTITE] =               [DAMAGE, damage_score_function, "CHIP_STALACTITE"];
skills[WEAPON_AXE] =                    [DAMAGE, damage_score_function, "WEAPON_AXE"];
skills[WEAPON_B_LASER] =                [DAMAGE, damage_score_function, "WEAPON_B_LASER"];
skills[WEAPON_BROADSWORD] =             [DAMAGE, damage_score_function, "WEAPON_BROADSWORD"];
skills[WEAPON_DESTROYER] =              [DAMAGE, damage_score_function, "WEAPON_DESTROYER"];
skills[WEAPON_DOUBLE_GUN] =             [DAMAGE, damage_score_function, "WEAPON_DOUBLE_GUN"];
skills[WEAPON_ELECTRISOR] =             [DAMAGE, damage_score_function, "WEAPON_ELECTRISOR"];
skills[WEAPON_FLAME_THROWER] =          [DAMAGE, damage_score_function, "WEAPON_FLAME_THROWER"];
skills[WEAPON_GAZOR] =                  [DAMAGE, default_score_function, "WEAPON_GAZOR"];
skills[WEAPON_GRENADE_LAUNCHER] =       [DAMAGE, damage_score_function, "WEAPON_GRENADE_LAUNCHER"];
skills[WEAPON_LASER] =                  [DAMAGE, damage_score_function, "WEAPON_LASER"];
skills[WEAPON_MACHINE_GUN] =            [DAMAGE, damage_score_function, "WEAPON_MACHINE_GUN"];
skills[WEAPON_MAGNUM] =                 [DAMAGE, damage_score_function, "WEAPON_MAGNUM"];
skills[WEAPON_KATANA] =                 [DAMAGE, damage_score_function, "WEAPON_KATANA"];
skills[WEAPON_M_LASER] =                [DAMAGE, damage_score_function, "WEAPON_M_LASER"];
skills[WEAPON_PISTOL] =                 [DAMAGE, damage_score_function, "WEAPON_PISTOL"];
skills[WEAPON_SHOTGUN] =                [DAMAGE, damage_score_function, "WEAPON_SHOTGUN"];
skills[WEAPON_AXE+1000] =               [DAMAGE, default_score_function, "EQ_AND_USE_WEAPON_AXE"];
skills[WEAPON_B_LASER+1000] =           [DAMAGE, default_score_function, "EQ_AND_USE_WEAPON_B_LASER"];
skills[WEAPON_BROADSWORD+1000] =        [DAMAGE, default_score_function, "EQ_AND_USE_WEAPON_BROADSWORD"];
skills[WEAPON_DESTROYER+1000] =         [DAMAGE, default_score_function, "EQ_AND_USE_WEAPON_DESTROYER"];
skills[WEAPON_DOUBLE_GUN+1000] =        [DAMAGE, default_score_function, "EQ_AND_USE_WEAPON_DOUBLE_GUN"];
skills[WEAPON_ELECTRISOR+1000] =        [DAMAGE, default_score_function, "EQ_AND_USE_WEAPON_ELECTRISOR"];
skills[WEAPON_FLAME_THROWER+1000] =     [DAMAGE, default_score_function, "EQ_AND_USE_WEAPON_FLAME_THROWER"];
skills[WEAPON_GAZOR+1000] =         	[DAMAGE, default_score_function, "EQ_AND_USE_WEAPON_GAZOR"];
skills[WEAPON_GRENADE_LAUNCHER+1000] =	[DAMAGE, default_score_function, "EQ_AND_USE_WEAPON_GRENADE_LAUNCHER"];
skills[WEAPON_KATANA+1000] =        	[DAMAGE, default_score_function, "EQ_AND_USE_WEAPON_KATANA"];
skills[WEAPON_LASER+1000] =         	[DAMAGE, default_score_function, "EQ_AND_USE_WEAPON_LASER"];
skills[WEAPON_MACHINE_GUN+1000] =   	[DAMAGE, default_score_function, "EQ_AND_USE_WEAPON_MACHINE_GUN"];
skills[WEAPON_MAGNUM+1000] =        	[DAMAGE, default_score_function, "EQ_AND_USE_WEAPON_MAGNUM"];
skills[WEAPON_M_LASER+1000] =       	[DAMAGE, default_score_function, "EQ_AND_USE_WEAPON_M_LASER"];
skills[WEAPON_PISTOL+1000] =        	[DAMAGE, default_score_function, "EQ_AND_USE_WEAPON_PISTOL"];
skills[WEAPON_SHOTGUN+1000] =			[DAMAGE, default_score_function, "EQ_AND_USE_WEAPON_SHOTGUN"];
skills[CHIP_ACCELERATION] =             [BUFF, default_score_function, "CHIP_ACCELERATION"];
skills[CHIP_ADRENALINE] =               [BUFF, default_score_function, "CHIP_ADRENALINE"];
skills[CHIP_ANTIDOTE] =                 [BUFF, default_score_function, "CHIP_ANTIDOTE"];
skills[CHIP_BARK] =                     [BUFF, default_score_function, "CHIP_BARK"];
skills[CHIP_COLLAR] =                   [BUFF, default_score_function, "CHIP_COLLAR"];
skills[CHIP_DOPING] =                   [BUFF, default_score_function, "CHIP_DOPING"];
skills[CHIP_FEROCITY] =                 [BUFF, default_score_function, "CHIP_FEROCITY"];
skills[CHIP_LEATHER_BOOTS] =            [BUFF, default_score_function, "CHIP_LEATHER_BOOTS"];
skills[CHIP_MOTIVATION] =               [BUFF, default_score_function, "CHIP_MOTIVATION"];
skills[CHIP_PROTEIN] =                  [BUFF, buff_score_function, "CHIP_PROTEIN"];
skills[CHIP_RAGE] =                     [BUFF, default_score_function, "CHIP_RAGE"];
skills[CHIP_REFLEXES] =                 [BUFF, default_score_function, "CHIP_REFLEXES"];
skills[CHIP_SEVEN_LEAGUE_BOOTS] =       [BUFF, default_score_function, "CHIP_SEVEN_LEAGUE_BOOTS"];
skills[CHIP_SOLIDIFICATION] =           [BUFF, default_score_function, "CHIP_SOLIDIFICATION"];
skills[CHIP_STEROID] =                  [BUFF, default_score_function, "CHIP_STEROID"];
skills[CHIP_STRETCHING] =               [BUFF, default_score_function, "CHIP_STRETCHING"];
skills[CHIP_WARM_UP] =                  [BUFF, default_score_function, "CHIP_WARM_UP"];
skills[CHIP_WHIP] =                     [BUFF, default_score_function, "CHIP_WHIP"];
skills[CHIP_WINGED_BOOTS] =             [BUFF, default_score_function, "CHIP_WINGED_BOOTS"];
skills[CHIP_MIRROR] =                   [REFLECT, default_score_function, "CHIP_MIRROR"];
skills[CHIP_THORN] =                    [REFLECT, default_score_function, "CHIP_THORN"];
skills[CHIP_PLAGUE] =                   [POISON, default_score_function, "CHIP_PLAGUE"];
skills[CHIP_TOXIN] =                    [POISON, default_score_function, "CHIP_TOXIN"];
skills[CHIP_VENOM] =                    [POISON, default_score_function, "CHIP_VENOM"];
skills[CHIP_BANDAGE] =                  [HEAL, default_score_function, "CHIP_BANDAGE"];
skills[CHIP_CURE] =                     [HEAL, default_score_function, "CHIP_CURE"];
skills[CHIP_DRIP] =                     [HEAL, default_score_function, "CHIP_DRIP"];
skills[CHIP_FERTILIZER] =               [HEAL, default_score_function, "CHIP_FERTILIZER"];
skills[CHIP_LOAM] =                     [HEAL, default_score_function, "CHIP_LOAM"];
skills[CHIP_REGENERATION] =             [HEAL, default_score_function, "CHIP_REGENERATION"];
skills[CHIP_REMISSION] =                [HEAL, default_score_function, "CHIP_REMISSION"];
skills[CHIP_VACCINE] =                  [HEAL, default_score_function, "CHIP_VACCINE"];
skills[CHIP_ARMOR] =                    [ARMOR, default_score_function, "CHIP_ARMOR"];
skills[CHIP_ARMORING] =                 [ARMOR, default_score_function, "CHIP_ARMORING"];
skills[CHIP_CARAPACE] =                 [ARMOR, default_score_function, "CHIP_CARAPACE"];
skills[CHIP_FORTRESS] =                 [ARMOR, default_score_function, "CHIP_FORTRESS"];
skills[CHIP_HELMET] =                   [ARMOR, default_score_function, "CHIP_HELMET"];
skills[CHIP_RAMPART] =                  [ARMOR, default_score_function, "CHIP_RAMPART"];
skills[CHIP_SHIELD] =                   [ARMOR, default_score_function, "CHIP_SHIELD"];
skills[CHIP_WALL] =                     [ARMOR, default_score_function, "CHIP_WALL"];
skills[CHIP_BALL_AND_CHAIN] =           [DEBUFF, default_score_function, "CHIP_BALL_AND_CHAIN"];
skills[CHIP_FRACTURE] =                 [DEBUFF, default_score_function, "CHIP_FRACTURE"];
skills[CHIP_SLOW_DOWN] =                [DEBUFF, default_score_function, "CHIP_SLOW_DOWN"];
skills[CHIP_SOPORIFIC] =                [DEBUFF, default_score_function, "CHIP_SOPORIFIC"];
skills[CHIP_TRANQUILIZER] =             [DEBUFF, default_score_function, "CHIP_TRANQUILIZER"];
skills[CHIP_INVERSION] =                [UTIL, default_score_function, "CHIP_INVERSION"];
skills[CHIP_LIBERATION] =               [UTIL, default_score_function, "CHIP_LIBERATION"];
skills[CHIP_RESURRECTION] =             [UTIL, default_score_function, "CHIP_RESURRECTION"];
skills[CHIP_TELEPORTATION] =            [UTIL, default_score_function, "CHIP_TELEPORTATION"];
skills[CHIP_FIRE_BULB] =                [BULB, default_score_function, "CHIP_FIRE_BULB"];
skills[CHIP_HEALER_BULB] =              [BULB, default_score_function, "CHIP_HEALER_BULB"];
skills[CHIP_ICED_BULB] =                [BULB, default_score_function, "CHIP_ICED_BULB"];
skills[CHIP_LIGHTNING_BULB] =           [BULB, default_score_function, "CHIP_LIGHTNING_BULB"];
skills[CHIP_METALLIC_BULB] =            [BULB, default_score_function, "CHIP_METALLIC_BULB"];
skills[CHIP_PUNY_BULB] =                [BULB, default_score_function, "CHIP_PUNY_BULB"];
skills[CHIP_ROCKY_BULB] =               [BULB, default_score_function, "CHIP_ROCKY_BULB"];


/**********************************************************************/

/**********************************************************************/
function getSkillName(skill){
	return skills[skill][NAME];
}

/**********************************************************************/
// Génère un tableau de valeur avec le coût de tous les chips/weapons du leek
// Chaque coût n'apparait qu'une fois (même si deux chips on un coup de 4, il n'y 
// aura qu'une seule fois la valeur 4 dans le tableau)
// Le tableau est trier par ordre croissant de coût
// Le tableau sert comme point d'entré pour la fonction generateCostCombosList()
/**********************************************************************/
function generateSkillsCostList(){
	//add change weapon

	var costs = [];
	var sortedCosts = [];
	var sortedUniqueCosts = [];
	
	var chips = getChips();
	var weapons = getWeapons();
	
	//Fill costs with all the weapon costs
	for (var weapon in weapons){
		push(costs, getWeaponCost(weapon));
		//add the cost of the weapon + the cost of the equipment
		push(costs, getWeaponCost(weapon)+1);
	}
	//Add to costs all the chip costs
	for (var chip in chips){
		if (getCooldown(chip) == 0){
			push(costs, getChipCost(chip));
		}
	}
	
	// sort costs
	sortedCosts = arraySort(costs, function(cost1, cost2) {
    	return cost1 - cost2;
	});
	
	// remove the costs that appears more than once
	var sortedCostsCount = count(sortedCosts);
	
	// The very first cost is necessarly unique
	push(sortedUniqueCosts, sortedCosts[0]);
	
	// Check if the previous cost is the same as the current one
	// if not thje cost is pushed to sortedUniqueCosts
	for (var i = 1;  i < sortedCostsCount; i++){
		if (sortedCosts[i] != sortedCosts[i-1]){
			push(sortedUniqueCosts, sortedCosts[i]);
		}
	}
	
	return sortedUniqueCosts;
}


/**************************************************************************/
// Fonction récursive calculant toutes les combos optimums de valeurs possibles
// Les valeurs représentent les différent points de tour des chips/armes du leek 
// Un combo est un tableau de valeurs. Ex : [3,3,3] 
// Les combos sont constitués à partir d'un tableau de valeurs initiales. Ex:[3,4,5]
// Le tableau de valeur initiales doit être dans l'ordre croissant
// La somme d'un combo ne dois pas dépasser une valeur max (max de PT du leek)
// Un combo est optimal si aucune valeure supplémentaire ne peut être ajoutée
// Ex : si max = 10, [3,3,3] est optimal et [3,3] n'est pas optimal
// Les combos optimums sont stockés par la fonction dans un tableau nommé costCombosList

// exemple :
// initialValues = [3,4,5]
// max = 10
// costCombosList = [[5,5],[5,4],[5,3],[4,4],[4,3,3],[3,3,3]]

/**************************************************************************/


function generateCostCombosList(initialValues, max, unfinishedCombo){
	var addedResult = false;
	if (initialValues === null){
		push(costCombosList, unfinishedCombo);
		addedResult = true;
	}
	else{
		var sizeArray = count(initialValues);
		for (var i = sizeArray - 1; i >= 0; i--){
			//debugE("Function depth : " + depth + ", boucle : " + (sizeArray - i)+"/" + sizeArray);
			//displayArray(initialValues, "chiffres dispos");
			//displayArray(unfinishedCombo, "résultat précédent");
			if (sum(unfinishedCombo) + initialValues[i] < max){
				//debug("sum + " + initialValues[i] + " < max");
				var nextResult = unfinishedCombo;
				push(nextResult, initialValues[i]);
				//displayDoubleArray(costCombosList, "cost combos : ");
				if (!generateCostCombosList(initialValues, max, nextResult)){
					//debug("no result return:");
					push(costCombosList, nextResult);
					//displayDoubleArray(costCombosList, "cost combos : ");
				}
				addedResult = true;
			}
			else if(sum(unfinishedCombo) + initialValues[i] == max){
				//debug("sum + " + initialValues[i] + " == max");
				var nextResult = unfinishedCombo;
				push(nextResult, initialValues[i]);
				push(costCombosList, nextResult);
				addedResult = true;
				//displayDoubleArray(costCombosList, "cost combos : ");
			}
			pop(initialValues);
		}
	}
	//debugW("depth : " + depth--);
	return addedResult;
}


/*************************************************************************/
// Prepare the input parameters used by the function fillCombo.
// skillSortedByCosts is a two dimensionnal array. The first dimmension is the cost of the skills, the second one is the id of the skills.
// skillSortedByCosts = (3)[a,b]
//						(4)[c,d]
//						(5)[e]

function sortSkillsByCost(){

	var chips = getChips();
	var weapons = getWeapons();
	
	for (var weapon in weapons){
		var weaponCost = getWeaponCost(weapon);
		if (skillSortedByCosts[weaponCost] === null)
			skillSortedByCosts[weaponCost] = [];
			
		push(skillSortedByCosts[weaponCost], weapon);
		
		//handle the weapon + the equipment
		if (skillSortedByCosts[weaponCost+1] === null)
			skillSortedByCosts[weaponCost+1] = [];

		push(skillSortedByCosts[weaponCost+1], weapon+1000);
	}
	
	for (var chip in chips){
		//Only the chip that are not on cooldown are stored
		if (getCooldown(chip) == 0){
			var chipCost = getChipCost(chip);
			if (skillSortedByCosts[chipCost] === null)
				skillSortedByCosts[chipCost] = [];

			push(skillSortedByCosts[chipCost], chip);
		}
	}
	
	debug("skillSortedByCosts" + skillSortedByCosts);
}


/*************************************************************************/
// call fillCombo as many time as there are combos

function generateCombosList(){	
	for (var costCombo in costCombosList){
		fillCombo(costCombo, 0, skillSortedByCosts);
	}
}

/************************************************************************/
// Fonction itérative générant tous les combos possibles à partir d'un combo de coût
// Gère les cooldowns

/* exemple d'execution de la fonction
4-4-3-3  a=4 b=4  c=3 d=3

4-4-3-3: a,b c,d
	a-4-3-3 : a,b  c,d 
		a-a-3-3 : c,d 
			a-a-c-3 : c,d
				a-a-c-c 
				a-a-c-d 
			a-a-d-3 : d 
				a-a-d-d 
		a-b-3-3 : c,d 	
			a-b-c-3 : c,d
				a-b-c-c 
				a-b-c-d 
			a-b-d-3 : d 
				a-b-d-d 
	b-4-3-3 : b  c,d 
		b-b-3-3 : c,d	
			b-b-c-3 : c,d
				b-b-c-c 
				b-b-c-d 
			b-b-d-3 : d 
				b-b-d-d 
*/
function fillCombo(combo, depth, skillsAvailable){
	
	if (count(combo) == depth){
		//displayArray(combo, "combo to push");
		push(combosList, combo);
	}
	else {
		//debug("depth: " + depth);
		//debug("combo[depth]: " + combo[depth]);
		//debug("combo: " + combo);
		//debug("skillsAvailable[combo[depth]]: " + skillsAvailable[combo[depth]]);
		//debug("skillsAvailable: " + skillsAvailable);
		if (count(skillsAvailable[combo[depth]]) == 0){
		
			var nextCombo = combo;
			//displayArray(nextCombo, "combo avant: ");
			remove(nextCombo, depth);
			//displayArray(nextCombo, "combo après: ");
			fillCombo(nextCombo, depth, skillsAvailable);
		}
		else{
			var partialskillsAvailable = skillsAvailable;	
			for (var skill in skillsAvailable[combo[depth]]){
				var skillRemoved = false;
				var nextCombo = combo;
				var nextDepth = depth + 1;
				nextCombo[depth] = skill;
				if (isChip(skill)){
					if (getChipCooldown(skill) != 0){
						//debug("chip : " + skill + ", cooldown : " + getChipCooldown(skill));
						remove(partialskillsAvailable[combo[depth]],0);
						skillRemoved = true;
					}
				}
				fillCombo(nextCombo, nextDepth, partialskillsAvailable);
				if (skillRemoved == false){
					remove(partialskillsAvailable[combo[depth]],0);
				}
			}
		}	
	}
}



/*************************************************************************/
function filterCombos(){
	for (var combo in combosList){
		if (filterCombo(combo)){
			push(filteredCombosList, combo);
		}
	}
}

/*************************************************************************/
// This function calls every filtering functions
// Return false to remove the combo
// Return true to keep the combo
function filterCombo(combo){
	if (!weaponFilter(combo)) {return false;}
	// add other filters here

	return true;
}


/*******************************************************************/
// Call sort Combo as many time as there are combos
// It sorts the combos themselves, not the list of the combos

function sortCombos(){
	for (var combo in filteredCombosList){
		push(sortedCombosList, sortCombo(combo));
	}
}

/*******************************************************************/
// function used to sort the skills of a combo.
// * some skills must be played first (e.g. buff and debuff before attacks)
// * weapons should be equiped before being used (not implemented)
// * if a combo can only be partially executed, some skills should be executed prioritarly (not implemented)
// * the skill execution ordrer influence the best path (not implemented)

function sortCombo(combo){
		var buffSkills = [];
		var armorSkills = [];
		var healSkills = [];
		var debuffSkills = [];
		var damageSkills = [];
		var bulbSkills = [];
		var poisonSkills = [];
		var utilSkills = [];
		var reflectSkills = [];
		
		for (var skill in combo){
			if (skills[skill][TYPE] == DAMAGE) {push(damageSkills, skill);}
			if (skills[skill][TYPE] == BUFF) {push(buffSkills, skill);}
			if (skills[skill][TYPE] == REFLECT) {push(reflectSkills, skill);}
			if (skills[skill][TYPE] == POISON) {push(poisonSkills, skill);}
			if (skills[skill][TYPE] == HEAL) {push(healSkills, skill);}
			if (skills[skill][TYPE] == ARMOR) {push(armorSkills, skill);}
			if (skills[skill][TYPE] == DEBUFF) {push(debuffSkills, skill);}
			if (skills[skill][TYPE] == UTIL) {push(utilSkills, skill);}
			if (skills[skill][TYPE] == BULB) {push(bulbSkills, skill);}
		}
		var sortedCombo = [];
		pushAll(sortedCombo, buffSkills);
		pushAll(sortedCombo, healSkills);
		pushAll(sortedCombo, armorSkills);
		pushAll(sortedCombo, reflectSkills);
		pushAll(sortedCombo, utilSkills);
		pushAll(sortedCombo, debuffSkills);
		pushAll(sortedCombo, damageSkills);
		pushAll(sortedCombo, poisonSkills);
		pushAll(sortedCombo, bulbSkills);
		
		//debug("unsorted combo : " + combo);
		//debug("sorted combo : " + sortedCombo);
		return sortedCombo;
}

/*************************************************************************/
// For each combo this function calls calculateComboScore
// It then stores the score and the key associated to the combo in comboScores

// comboScores[0] = [scoreFirstCombo, keyFirstCombo];
// comboScores[1] = [scoreSecondCombo, keySecondCombo];
// comboScores[n] = [...];
 
function calculateCombosScore(){

	ourLeekCarac = getLeekCarac(ourLeekID);
	enemyLeekCarac = getLeekCarac(enemyID);

	ourLeekCaracTemp = ourLeekCarac;
	enemyLeekCaracTemp = enemyLeekCarac;

	for (var key : var combo in sortedCombosList){
		ourLeekCaracTemp = ourLeekCarac;
		enemyLeekCaracTemp = enemyLeekCarac;

		var score = calculateComboScore(combo);
		var scoreAndKey = [];
		scoreAndKey[SCORE] = score;
		scoreAndKey[KEY] = key;

		push(comboScores, scoreAndKey);
	}
}


/*************************************************************************/
// This function calls 

function calculateComboScore(combo){
	var score = 0;

	for (var skill in combo){
			score += skills[skill][SCORE_FUNCTION](skill);
	}

	return score;
}


/*************************************************************************/
// This function sorts all the combo by score 

function sortCombosByScore(){
	// sort costs
	sortedComboScores = arraySort(comboScores, function(comboScore1, comboScore2) {
    	return comboScore2[SCORE] - comboScore1[SCORE];
	});
}


/*************************************************************************/
// This function is used to find the trajectory with the best score without 
// using more operation than the maximum operation limit
// operationThreshold to be improved
function find_best_trajectory(){
	var operationThreshold = 4000000;

	var nbOp = getOperations();
	fill_danger_map();
	fill_safe_nodes();
	debug("nb instruct fill_danger_map : " + (getOperations() - nbOp));
	var countTrajectories = 0;

	for (var comboScore in sortedComboScores){
		//debug("combo: " + sortedCombosList[comboScore[KEY]]);
		fill_action_nodes(sortedCombosList[comboScore[KEY]]);
		generate_trajectories(sortedCombosList[comboScore[KEY]]);
		countTrajectories++;

		if (OPERATIONS_LIMIT - getOperations() < operationThreshold){
			debug("remaing operation inferior to " + operationThreshold);			
			break;
		}
	}
	debug("Trajectories calculated: " + countTrajectories);
}

/*************************************************************************/
// This function is used to fill the danger map based on 
//  * the chips and weapons of the enemy leek
//  * the chips of the enemy bulbs (not implemented yet)
function fill_danger_map(){
	
	var enemySkills = [];
	pushAll(enemySkills, getChips(enemyID));
	pushAll(enemySkills, getWeapons(enemyID));

	for (var skill in enemySkills){
		if (skills[skill][TYPE] == DEBUFF || skills[skill][TYPE] == DAMAGE || skills[skill][TYPE] == POISON){
			if (dangerNodes[skill] == null){
				canUseIfMoving(skill,  getCell(enemyID),  enemyID, true,  false);
			}
		}
	}
}

/*************************************************************************/
// This function is used to find the trajectory that with the best score
// This function doesn't handle chips cast on allies (to be improved)
function fill_action_nodes(combo){
	for (var skill in combo){
		if (skill > 1000)
			skill -= 1000;

		if (getType() == ENTITY_LEEK){	
			if (skills[skill][TYPE] == DEBUFF || skills[skill][TYPE] == DAMAGE || skills[skill][TYPE] == POISON){
				if (actionNodes[skill] == null){
					canUseIfMoving(skill,  getCell(enemyID),  ourLeekID, true,  false);
				}
			}
		}
		else {
			debug("fill_action_nodes: case not handled");
		}
	}
}


/*************************************************************************/
// This function is used to generate the different trajectories of a combo
// There are trajectories for:
//  * full combo + mvmt
//  * full combo
//  * full indirect combo + mvmt
//  * full indirect combo
// A trajectory can be full (all the skills can be used) or partial
// A trajectory is an array : [[cell1, cell2, ...], [skill1, skill2, ...], [targetCell1, targetCell2, ...] [MPUsed1, MPUsed2, ...], score]
// The number of MP depends on the casted chips (not implemented yet)

function generate_trajectories(combo){
	trajectories = [];
	generate_basic_trajectories(combo);
	debug("combo: " + combo);
	debug("trajectories: " + trajectories);
	pushAll(allTrajectories, trajectories);
}

/*************************************************************************/
// This function is used to generate the direct and indirect trajectories of a combo
// To be improved : copy the beginning of "direct" in "indirect" until a skill has AOE
function generate_basic_trajectories(combo){

	var direct = [];
	direct[SKILL] = [];
	direct[CELLS] = [];
	direct[MVMP] = [];
	direct[TARGET_CELL] = [];	
	var indirect = [];
	indirect[SKILL] = [];
	indirect[CELLS] = [];
	indirect[MVMP] = [];
	indirect[TARGET_CELL] = [];

	//debug("direct combo: " + combo);
	// generate direct trajectories without escape
	for (var key: var skill in combo){
		//debug("skill: " + skill);
		var nextNodeResult = [];
		// if the skill requires a mouvment to be executed
		if (skills[skill][TYPE] == DEBUFF || skills[skill][TYPE] == DAMAGE || skills[skill][TYPE] == POISON){

			if (key == 0){
				nextNodeResult = find_next_node(skill, getCell(), direct, getMP());
			}
			else {
				nextNodeResult = find_next_node(skill, direct[CELLS][key - 1], direct, (getMP() - sum(direct[MVMP])));
			}
			// if a cell can be reached then save it in the trajectory
			if (nextNodeResult[TYPE] == true){
				push(direct[SKILL], skill);
				push(direct[CELLS], nextNodeResult[CELLS]);
				push(direct[MVMP], nextNodeResult[MVMP]);
				push(direct[TARGET_CELL], nextNodeResult[TARGET_CELL]);
			}
		}
		// if the skill does not require a mouvment to be executed
		else {
			if (key == 0){
				push(direct[SKILL], skill);
				push(direct[CELLS], getCell());
				push(direct[MVMP], 0);
				push(direct[TARGET_CELL], getCell());
			}
			else{
				push(direct[SKILL], skill);
				push(direct[CELLS], direct[CELLS][key - 1]);
				push(direct[MVMP], 0);
				push(direct[TARGET_CELL], direct[CELLS][key - 1]);
			}
		}
	}

	//debug("indirect combo: " + combo);
	// generate indirect trajectories without escape
		for (var key: var skill in combo){
		var nextNodeResult = [];
		// if the skill requires a mouvment to be executed
		if (skills[skill][TYPE] == DEBUFF || skills[skill][TYPE] == DAMAGE || skills[skill][TYPE] == POISON){

			if (key == 0){
				nextNodeResult = find_next_node(skill, getCell(), indirect, getMP());
			}
			else {
				nextNodeResult = find_next_node(skill, indirect[CELLS][key - 1], indirect, (getMP() - sum(indirect[MVMP])));
			}
			// if a cell can be reached then save it in the trajectory
			if (nextNodeResult[TYPE] == true){
				push(indirect[SKILL], skill);
				push(indirect[CELLS], nextNodeResult[CELLS]);
				push(indirect[MVMP], nextNodeResult[MVMP]);
				push(indirect[TARGET_CELL], nextNodeResult[TARGET_CELL]);

			}
		}
		// if the skill does not require a mouvment to be executed
		else {
			if (key == 0){
				push(indirect[SKILL], skill);
				push(indirect[CELLS], getCell());
				push(indirect[MVMP], 0);
				push(indirect[TARGET_CELL], getCell());

			}
			else{
				push(indirect[SKILL], skill);
				push(indirect[CELLS], indirect[CELLS][key - 1]);
				push(indirect[MVMP], 0);
				push(indirect[TARGET_CELL], direct[CELLS][key - 1]);
			}
		}
	}

	// Check if there is at least one skill used in the trajectories 
	if (!isEmpty(direct[SKILL])){
		push(trajectories, direct);
	}
	// Check if there is at least one skill used in the trajectories 
	if (!isEmpty(indirect[SKILL])){
		push(trajectories, indirect);
	}
}

/*************************************************************************/
// This function is used to find the next node
// The chosen node is the closest node
// returns an array [cellFound, cell, MPused, targetCell]

function find_next_node(skill, currentCell, direct, mpAvailable){
    var nodes = [];
    // if you want to find a safe place then look in the safe nodes
    if (skill == 2000){
            nodes = safeNodes;
    }
    // otherwise look in the action nodes
    else {
        if (skill > 1000){
                skill -= 1000;
        }      
        nodes = actionNodes[skill];
    }

    var result = [];
    result[TYPE] = false;
    result[MVMP] = 1000;

	//debug("mpAvailable: " + mpAvailable);

    for (var node in nodes){
		// Check if this node can do a direct hit 
		if (direct && node["TARGET_CELL"] != node["INDIRECT_CELL"]){
			continue;
		}

		var pathLength = getPathLength(currentCell, node["CELL"]);
		//debug("pathLength: " + pathLength);
		if (pathLength != null){
			if (pathLength < result[MVMP] && pathLength <= mpAvailable){
				result[TARGET_CELL] = node["INDIRECT_CELL"];
				result[MVMP] = pathLength;
				result[CELLS] = node["CELL"];
				result[TYPE] = true;

				if (pathLength == 0){
					break;
				}
			}
		}
	}

	return result;
}

/*************************************************************************/
// This function is used fill the action sequence with the best trajectory
function fill_action_sequence(){

	debug(" ");
	debug("combo: " + allTrajectories[0]);
	for (var key : var skill in allTrajectories[0][SKILL]){
		//move to cell
		actionSequence[actionTotal] = [];
		actionSequence[actionTotal][0] = MOVE_TO_CELL;	
		actionSequence[actionTotal][1] = allTrajectories[0][CELLS][key];			
		actionTotal++;

            if (skill != 2000){
                //equip weapon if required
                if (skill > 1000){
                        skill -= 1000;
                        actionSequence[actionTotal] = [];
                        actionSequence[actionTotal][0] = EQUIP_WEAPON;
                        actionSequence[actionTotal][1] = skill;
                        actionTotal++;
                }

                //use skill
                actionSequence[actionTotal] = [];
                actionSequence[actionTotal][0] = USE_OBJECT;
                actionSequence[actionTotal][1] = skill;
                actionSequence[actionTotal][2] = allTrajectories[0][TARGET_CELL][key];

                actionTotal++;
        }
	}
}

/*************************************************************************/
// This function is used fill the safeNodes with untargetable cell 
// TO BE IMPROVED to quantify the danger
function fill_safe_nodes(){
        var area = getArea(getMP(), getCell());

        for (var cell in area){
                if (dangerMap[cell] == null){
                        var node = [];
                        node["CELL"] = cell;
                        push(safeNodes, node);
                }
        }
}