include("GlobalVar");
include("util_misc");
include("util_filters");
include("util_score");
include("util_can_use");

global BUFF = 		"BUFF";
global ARMOR = 		"ARMOR";
global HEAL = 		"HEAL";
global DEBUFF = 	"DEBUFF";
global DAMAGE = 	"DAMAGE";
global BULB = 		"BULB";
global POISON = 	"POISON";
global UTIL = 		"UTIL"; // peut être à modifier
global REFLECT = 	"REFLECT";

global TYPE = 0;
global SCORE_FUNCTION = 1;
global NAME = 2;

global SCORE = "SCORE";
global TOTAL_SCORE = "TOTAL_SCORE";
global KEY = "KEY";

global SKILL = "SKILL";
global CELLS = "CELLS";
global MVMP = "MVMP";
global TARGET_CELL = "TGT_CELL";

global MOVE = 200;

global DIRECT = 0;
global INDIRECT = 1;

global skills = [];						//[To sort the combos, to calculate the score]
skills[MOVE] =                  		[UTIL, default_score_function, "MOVE"];
skills[CHIP_BURNING] =                  [DAMAGE, damage_score_function, "CHIP_BURNING"];
skills[CHIP_DEVIL_STRIKE] =             [DAMAGE, damage_score_function, "CHIP_DEVIL_STRIKE"];
skills[CHIP_FLAME] =                    [DAMAGE, damage_score_function, "CHIP_FLAME"];
skills[CHIP_FLASH] =                    [DAMAGE, damage_score_function, "CHIP_FLASH"];
skills[CHIP_ICE] =                      [DAMAGE, damage_score_function, "CHIP_ICE"];
skills[CHIP_ICEBERG] =                  [DAMAGE, damage_score_function, "CHIP_ICEBERG"];
skills[CHIP_LIGHTNING] =                [DAMAGE, damage_score_function, "CHIP_LIGHTNING"];
skills[CHIP_METEORITE] =                [DAMAGE, damage_score_function, "CHIP_METEORITE"];
skills[CHIP_PEBBLE] =                   [DAMAGE, damage_score_function, "CHIP_PEBBLE"];
skills[CHIP_ROCK] =                     [DAMAGE, damage_score_function, "CHIP_ROCK"];
skills[CHIP_ROCKFALL] =                 [DAMAGE, damage_score_function, "CHIP_ROCKFALL"];
skills[CHIP_SHOCK] =                    [DAMAGE, damage_score_function, "CHIP_SHOCK"];
skills[CHIP_SPARK] =                    [DAMAGE, damage_score_function, "CHIP_SPARK"];
skills[CHIP_STALACTITE] =               [DAMAGE, damage_score_function, "CHIP_STALACTITE"];
skills[WEAPON_AXE] =                    [DAMAGE, damage_score_function, "WEAPON_AXE"];
skills[WEAPON_B_LASER] =                [DAMAGE, damage_score_function, "WEAPON_B_LASER"];
skills[WEAPON_BROADSWORD] =             [DAMAGE, damage_score_function, "WEAPON_BROADSWORD"];
skills[WEAPON_DESTROYER] =              [DAMAGE, damage_score_function, "WEAPON_DESTROYER"];
skills[WEAPON_DOUBLE_GUN] =             [DAMAGE, damage_score_function, "WEAPON_DOUBLE_GUN"];
skills[WEAPON_ELECTRISOR] =             [DAMAGE, damage_score_function, "WEAPON_ELECTRISOR"];
skills[WEAPON_FLAME_THROWER] =          [DAMAGE, damage_score_function, "WEAPON_FLAME_THROWER"];
skills[WEAPON_GAZOR] =                  [POISON, poison_score_function, "WEAPON_GAZOR"];
skills[WEAPON_GRENADE_LAUNCHER] =       [DAMAGE, damage_score_function, "WEAPON_GRENADE_LAUNCHER"];
skills[WEAPON_LASER] =                  [DAMAGE, damage_score_function, "WEAPON_LASER"];
skills[WEAPON_MACHINE_GUN] =            [DAMAGE, damage_score_function, "WEAPON_MACHINE_GUN"];
skills[WEAPON_MAGNUM] =                 [DAMAGE, damage_score_function, "WEAPON_MAGNUM"];
skills[WEAPON_KATANA] =                 [DAMAGE, damage_score_function, "WEAPON_KATANA"];
skills[WEAPON_M_LASER] =                [DAMAGE, damage_score_function, "WEAPON_M_LASER"];
skills[WEAPON_PISTOL] =                 [DAMAGE, damage_score_function, "WEAPON_PISTOL"];
skills[WEAPON_SHOTGUN] =                [DAMAGE, damage_score_function, "WEAPON_SHOTGUN"];
skills[WEAPON_AXE+1000] =               [DAMAGE, damage_score_function, "EQ_AND_USE_WEAPON_AXE"];
skills[WEAPON_B_LASER+1000] =           [DAMAGE, damage_score_function, "EQ_AND_USE_WEAPON_B_LASER"];
skills[WEAPON_BROADSWORD+1000] =        [DAMAGE, damage_score_function, "EQ_AND_USE_WEAPON_BROADSWORD"];
skills[WEAPON_DESTROYER+1000] =         [DAMAGE, damage_score_function, "EQ_AND_USE_WEAPON_DESTROYER"];
skills[WEAPON_DOUBLE_GUN+1000] =        [DAMAGE, damage_score_function, "EQ_AND_USE_WEAPON_DOUBLE_GUN"];
skills[WEAPON_ELECTRISOR+1000] =        [DAMAGE, damage_score_function, "EQ_AND_USE_WEAPON_ELECTRISOR"];
skills[WEAPON_FLAME_THROWER+1000] =     [DAMAGE, damage_score_function, "EQ_AND_USE_WEAPON_FLAME_THROWER"];
skills[WEAPON_GAZOR+1000] =         	[DAMAGE, poison_score_function, "EQ_AND_USE_WEAPON_GAZOR"];
skills[WEAPON_GRENADE_LAUNCHER+1000] =	[DAMAGE, damage_score_function, "EQ_AND_USE_WEAPON_GRENADE_LAUNCHER"];
skills[WEAPON_KATANA+1000] =        	[DAMAGE, damage_score_function, "EQ_AND_USE_WEAPON_KATANA"];
skills[WEAPON_LASER+1000] =         	[DAMAGE, damage_score_function, "EQ_AND_USE_WEAPON_LASER"];
skills[WEAPON_MACHINE_GUN+1000] =   	[DAMAGE, damage_score_function, "EQ_AND_USE_WEAPON_MACHINE_GUN"];
skills[WEAPON_MAGNUM+1000] =        	[DAMAGE, damage_score_function, "EQ_AND_USE_WEAPON_MAGNUM"];
skills[WEAPON_M_LASER+1000] =       	[DAMAGE, damage_score_function, "EQ_AND_USE_WEAPON_M_LASER"];
skills[WEAPON_PISTOL+1000] =        	[DAMAGE, damage_score_function, "EQ_AND_USE_WEAPON_PISTOL"];
skills[WEAPON_SHOTGUN+1000] =			[DAMAGE, damage_score_function, "EQ_AND_USE_WEAPON_SHOTGUN"];

skills[CHIP_ARMORING] =                 [HEAL, boost_max_life_score_function, "CHIP_ARMORING"];
skills[CHIP_FERTILIZER] =               [HEAL, boost_max_life_score_function, "CHIP_FERTILIZER"];
skills[CHIP_LOAM] =                     [HEAL, boost_max_life_score_function, "CHIP_LOAM"];

skills[CHIP_BANDAGE] =                  [HEAL, heal_score_function, "CHIP_BANDAGE"];
skills[CHIP_CURE] =                     [HEAL, heal_score_function, "CHIP_CURE"];
skills[CHIP_DRIP] =                     [HEAL, default_score_function, "CHIP_DRIP"];
skills[CHIP_REGENERATION] =             [HEAL, heal_score_function, "CHIP_REGENERATION"];
skills[CHIP_REMISSION] =                [HEAL, default_score_function, "CHIP_REMISSION"];
skills[CHIP_VACCINE] =                  [HEAL, default_score_function, "CHIP_VACCINE"];

skills[CHIP_ACCELERATION] =             [BUFF, default_score_function, "CHIP_ACCELERATION"];
skills[CHIP_ADRENALINE] =               [BUFF, default_score_function, "CHIP_ADRENALINE"];
skills[CHIP_ANTIDOTE] =                 [BUFF, antidote_score_function, "CHIP_ANTIDOTE"];
skills[CHIP_BARK] =                     [BUFF, default_score_function, "CHIP_BARK"];
skills[CHIP_COLLAR] =                   [BUFF, default_score_function, "CHIP_COLLAR"];
skills[CHIP_DOPING] =                   [BUFF, default_score_function, "CHIP_DOPING"];
skills[CHIP_FEROCITY] =                 [BUFF, default_score_function, "CHIP_FEROCITY"];
skills[CHIP_LEATHER_BOOTS] =            [BUFF, default_score_function, "CHIP_LEATHER_BOOTS"];
skills[CHIP_MOTIVATION] =               [BUFF, default_score_function, "CHIP_MOTIVATION"];
skills[CHIP_PROTEIN] =                  [BUFF, buff_score_function, "CHIP_PROTEIN"];
skills[CHIP_RAGE] =                     [BUFF, default_score_function, "CHIP_RAGE"];
skills[CHIP_REFLEXES] =                 [BUFF, default_score_function, "CHIP_REFLEXES"];
skills[CHIP_SEVEN_LEAGUE_BOOTS] =       [BUFF, default_score_function, "CHIP_SEVEN_LEAGUE_BOOTS"];
skills[CHIP_SOLIDIFICATION] =           [BUFF, default_score_function, "CHIP_SOLIDIFICATION"];
skills[CHIP_STEROID] =                  [BUFF, default_score_function, "CHIP_STEROID"];
skills[CHIP_STRETCHING] =               [BUFF, default_score_function, "CHIP_STRETCHING"];
skills[CHIP_WARM_UP] =                  [BUFF, default_score_function, "CHIP_WARM_UP"];
skills[CHIP_WHIP] =                     [BUFF, default_score_function, "CHIP_WHIP"];
skills[CHIP_WINGED_BOOTS] =             [BUFF, default_score_function, "CHIP_WINGED_BOOTS"];
skills[CHIP_MIRROR] =                   [REFLECT, default_score_function, "CHIP_MIRROR"];
skills[CHIP_THORN] =                    [REFLECT, default_score_function, "CHIP_THORN"];
skills[CHIP_PLAGUE] =                   [POISON, poison_score_function, "CHIP_PLAGUE"];
skills[CHIP_TOXIN] =                    [POISON, poison_score_function, "CHIP_TOXIN"];
skills[CHIP_VENOM] =                    [POISON, poison_score_function, "CHIP_VENOM"];

skills[CHIP_ARMOR] =                    [ARMOR, armor_score_function, "CHIP_ARMOR"];
skills[CHIP_CARAPACE] =                 [ARMOR, armor_score_function, "CHIP_CARAPACE"];
skills[CHIP_FORTRESS] =                 [ARMOR, armor_score_function, "CHIP_FORTRESS"];
skills[CHIP_HELMET] =                   [ARMOR, armor_score_function, "CHIP_HELMET"];
skills[CHIP_RAMPART] =                  [ARMOR, armor_score_function, "CHIP_RAMPART"];
skills[CHIP_SHIELD] =                   [ARMOR, armor_score_function, "CHIP_SHIELD"];
skills[CHIP_WALL] =                     [ARMOR, armor_score_function, "CHIP_WALL"];
skills[CHIP_BALL_AND_CHAIN] =           [DEBUFF, default_score_function, "CHIP_BALL_AND_CHAIN"];
skills[CHIP_FRACTURE] =                 [DEBUFF, default_score_function, "CHIP_FRACTURE"];
skills[CHIP_SLOW_DOWN] =                [DEBUFF, default_score_function, "CHIP_SLOW_DOWN"];
skills[CHIP_SOPORIFIC] =                [DEBUFF, default_score_function, "CHIP_SOPORIFIC"];
skills[CHIP_TRANQUILIZER] =             [DEBUFF, default_score_function, "CHIP_TRANQUILIZER"];
skills[CHIP_INVERSION] =                [UTIL, default_score_function, "CHIP_INVERSION"];
skills[CHIP_LIBERATION] =               [DEBUFF, liberation_score_function, "CHIP_LIBERATION"]; //TO BE IMPROVED: could also be used as a util
skills[CHIP_RESURRECTION] =             [UTIL, default_score_function, "CHIP_RESURRECTION"];
skills[CHIP_TELEPORTATION] =            [UTIL, default_score_function, "CHIP_TELEPORTATION"];
skills[CHIP_FIRE_BULB] =                [BULB, bulb_score_function, "CHIP_FIRE_BULB"];
skills[CHIP_HEALER_BULB] =              [BULB, bulb_score_function, "CHIP_HEALER_BULB"];
skills[CHIP_ICED_BULB] =                [BULB, bulb_score_function, "CHIP_ICED_BULB"];
skills[CHIP_LIGHTNING_BULB] =           [BULB, bulb_score_function, "CHIP_LIGHTNING_BULB"];
skills[CHIP_METALLIC_BULB] =            [BULB, bulb_score_function, "CHIP_METALLIC_BULB"];
skills[CHIP_PUNY_BULB] =                [BULB, bulb_score_function, "CHIP_PUNY_BULB"];
skills[CHIP_ROCKY_BULB] =               [BULB, bulb_score_function, "CHIP_ROCKY_BULB"];


/**********************************************************************/

/**********************************************************************/
function getSkillName(skill){
	return skills[skill][NAME];
}

/**********************************************************************/
// Génère un tableau de valeur avec le coût de tous les chips/weapons du leek
// Chaque coût n'apparait qu'une fois (même si deux chips on un coup de 4, il n'y 
// aura qu'une seule fois la valeur 4 dans le tableau)
// Le tableau est trier par ordre croissant de coût
// Le tableau sert comme point d'entré pour la fonction generateCostCombosList()
/**********************************************************************/
function generateSkillsCostList(){
	//add change weapon

	var costs = [];
	var sortedCosts = [];
	var sortedUniqueCosts = [];
	
	var chips = getChips();
	var weapons = getWeapons();
	
	//Fill costs with all the weapon costs
	for (var weapon in weapons){
		push(costs, getWeaponCost(weapon));
		//add the cost of the weapon + the cost of the equipment
		push(costs, getWeaponCost(weapon)+1);
	}
	//Add to costs all the chip costs
	for (var chip in chips){
		if (getCooldown(chip) == 0){
			push(costs, getChipCost(chip));
		}
	}
	
	// sort costs
	sortedCosts = arraySort(costs, function(cost1, cost2) {
    	return cost1 - cost2;
	});
	
	// remove the costs that appears more than once
	var sortedCostsCount = count(sortedCosts);
	
	// The very first cost is necessarly unique
	push(sortedUniqueCosts, sortedCosts[0]);
	
	// Check if the previous cost is the same as the current one
	// if not thje cost is pushed to sortedUniqueCosts
	for (var i = 1;  i < sortedCostsCount; i++){
		if (sortedCosts[i] != sortedCosts[i-1]){
			push(sortedUniqueCosts, sortedCosts[i]);
		}
	}
	
	return sortedUniqueCosts;
}


/**************************************************************************/
// Fonction récursive calculant toutes les combos optimums de valeurs possibles
// Les valeurs représentent les différent points de tour des chips/armes du leek 
// Un combo est un tableau de valeurs. Ex : [3,3,3] 
// Les combos sont constitués à partir d'un tableau de valeurs initiales. Ex:[3,4,5]
// Le tableau de valeur initiales doit être dans l'ordre croissant
// La somme d'un combo ne dois pas dépasser une valeur max (max de PT du leek)
// Un combo est optimal si aucune valeure supplémentaire ne peut être ajoutée
// Ex : si max = 10, [3,3,3] est optimal et [3,3] n'est pas optimal
// Les combos optimums sont stockés par la fonction dans un tableau nommé costCombosList

// exemple :
// initialValues = [3,4,5]
// max = 10
// costCombosList = [[5,5],[5,4],[5,3],[4,4],[4,3,3],[3,3,3]]

/**************************************************************************/


function generateCostCombosList(initialValues, max, unfinishedCombo){
	var addedResult = false;
	if (initialValues === null){
		push(costCombosList, unfinishedCombo);
		addedResult = true;
	}
	else{
		var sizeArray = count(initialValues);
		for (var i = sizeArray - 1; i >= 0; i--){
			//debugE("Function depth : " + depth + ", boucle : " + (sizeArray - i)+"/" + sizeArray);
			//displayArray(initialValues, "chiffres dispos");
			//displayArray(unfinishedCombo, "résultat précédent");
			if (sum(unfinishedCombo) + initialValues[i] < max){
				//debug("sum + " + initialValues[i] + " < max");
				var nextResult = unfinishedCombo;
				push(nextResult, initialValues[i]);
				//displayDoubleArray(costCombosList, "cost combos : ");
				if (!generateCostCombosList(initialValues, max, nextResult)){
					//debug("no result return:");
					push(costCombosList, nextResult);
					//displayDoubleArray(costCombosList, "cost combos : ");
				}
				addedResult = true;
			}
			else if(sum(unfinishedCombo) + initialValues[i] == max){
				//debug("sum + " + initialValues[i] + " == max");
				var nextResult = unfinishedCombo;
				push(nextResult, initialValues[i]);
				push(costCombosList, nextResult);
				addedResult = true;
				//displayDoubleArray(costCombosList, "cost combos : ");
			}
			pop(initialValues);
		}
	}
	//debugW("depth : " + depth--);
	return addedResult;
}


/*************************************************************************/
// Prepare the input parameters used by the function fillCombo.
// skillSortedByCosts is a two dimensionnal array. The first dimmension is the cost of the skills, the second one is the id of the skills.
// skillSortedByCosts = (3)[a,b]
//						(4)[c,d]
//						(5)[e]

function sortSkillsByCost(){

	var chips = getChips();
	var weapons = getWeapons();
	
	for (var weapon in weapons){
		var weaponCost = getWeaponCost(weapon);
		if (skillSortedByCosts[weaponCost] === null)
			skillSortedByCosts[weaponCost] = [];
			
		push(skillSortedByCosts[weaponCost], weapon);
		
		//handle the weapon + the equipment
		if (skillSortedByCosts[weaponCost+1] === null)
			skillSortedByCosts[weaponCost+1] = [];

		push(skillSortedByCosts[weaponCost+1], weapon+1000);
	}
	
	for (var chip in chips){
		//Only the chip that are not on cooldown are stored
		if (getCooldown(chip) == 0){
			var chipCost = getChipCost(chip);
			if (skillSortedByCosts[chipCost] === null)
				skillSortedByCosts[chipCost] = [];

			push(skillSortedByCosts[chipCost], chip);
		}
	}
	
	//debug("skillSortedByCosts" + skillSortedByCosts);
}


/*************************************************************************/
// call fillCombo as many time as there are combos

function generateCombosList(){	
	for (var costCombo in costCombosList){
		fillCombo(costCombo, 0, skillSortedByCosts);
	}
}

/************************************************************************/
// Fonction récursive générant tous les combos possibles à partir d'un combo de coût
// Gère les cooldowns

/* exemple d'execution de la fonction
4-4-3-3  a=4 b=4  c=3 d=3

4-4-3-3: a,b c,d
	a-4-3-3 : a,b  c,d 
		a-a-3-3 : c,d 
			a-a-c-3 : c,d
				a-a-c-c 
				a-a-c-d 
			a-a-d-3 : d 
				a-a-d-d 
		a-b-3-3 : c,d 	
			a-b-c-3 : c,d
				a-b-c-c 
				a-b-c-d 
			a-b-d-3 : d 
				a-b-d-d 
	b-4-3-3 : b  c,d 
		b-b-3-3 : c,d	
			b-b-c-3 : c,d
				b-b-c-c 
				b-b-c-d 
			b-b-d-3 : d 
				b-b-d-d 
*/
function fillCombo(combo, depth, skillsAvailable){
	
	if (count(combo) == depth){
		//displayArray(combo, "combo to push");
		push(combosList, combo);
	}
	else {
		//debug("depth: " + depth);
		//debug("combo[depth]: " + combo[depth]);
		//debug("combo: " + combo);
		//debug("skillsAvailable[combo[depth]]: " + skillsAvailable[combo[depth]]);
		//debug("skillsAvailable: " + skillsAvailable);
		if (count(skillsAvailable[combo[depth]]) == 0){
		
			var nextCombo = combo;
			//displayArray(nextCombo, "combo avant: ");
			remove(nextCombo, depth);
			//displayArray(nextCombo, "combo après: ");
			fillCombo(nextCombo, depth, skillsAvailable);
		}
		else{
			var partialskillsAvailable = skillsAvailable;	
			for (var skill in skillsAvailable[combo[depth]]){
				var skillRemoved = false;
				var nextCombo = combo;
				var nextDepth = depth + 1;
				nextCombo[depth] = skill;
				if (isChip(skill)){
					if (getChipCooldown(skill) != 0){
						//debug("chip : " + skill + ", cooldown : " + getChipCooldown(skill));
						remove(partialskillsAvailable[combo[depth]],0);
						skillRemoved = true;
					}
				}
				fillCombo(nextCombo, nextDepth, partialskillsAvailable);
				if (skillRemoved == false){
					remove(partialskillsAvailable[combo[depth]],0);
				}
			}
		}	
	}
}



/*************************************************************************/
function filterCombos(){
	for (var combo in combosList){
		if (filterCombo(combo)){
			push(filteredCombosList, combo);
		}
	}
}

/*************************************************************************/
// This function calls every filtering functions
// Return false to remove the combo
// Return true to keep the combo
function filterCombo(combo){
	if (!weaponFilter(combo)) {return false;}
	// add other filters here

	return true;
}


/*******************************************************************/
// Call sort Combo as many time as there are combos
// It sorts the combos themselves, not the list of the combos

function sortCombos(){
	for (var combo in filteredCombosList){
		push(sortedCombosList, sortCombo(combo));
	}
}

/*******************************************************************/
// TO BE IMPROVED
// function used to sort the skills of a combo.
// * some skills must be played first (e.g. buff and debuff before attacks)
// * weapons should be equiped before being used (not implemented)
// * if a combo can only be partially executed, some skills should be executed prioritarly (not implemented)
// * the skill execution ordrer influence the best path (not implemented)

function sortCombo(combo){
		var buffSkills = [];
		var armorSkills = [];
		var healSkills = [];
		var debuffSkills = [];
		var damageSkills = [];
		var bulbSkills = [];
		var poisonSkills = [];
		var utilSkills = [];
		var reflectSkills = [];
		
		for (var skill in combo){
			if (skills[skill][TYPE] == DAMAGE) {push(damageSkills, skill);}
			if (skills[skill][TYPE] == BUFF) {push(buffSkills, skill);}
			if (skills[skill][TYPE] == REFLECT) {push(reflectSkills, skill);}
			if (skills[skill][TYPE] == POISON) {push(poisonSkills, skill);}
			if (skills[skill][TYPE] == HEAL) {push(healSkills, skill);}
			if (skills[skill][TYPE] == ARMOR) {push(armorSkills, skill);}
			if (skills[skill][TYPE] == DEBUFF) {push(debuffSkills, skill);}
			if (skills[skill][TYPE] == UTIL) {push(utilSkills, skill);}
			if (skills[skill][TYPE] == BULB) {push(bulbSkills, skill);}
		}
		var sortedCombo = [];
		pushAll(sortedCombo, buffSkills);
		pushAll(sortedCombo, healSkills);
		pushAll(sortedCombo, armorSkills);
		pushAll(sortedCombo, reflectSkills);
		pushAll(sortedCombo, utilSkills);
		pushAll(sortedCombo, debuffSkills);
		pushAll(sortedCombo, damageSkills);
		pushAll(sortedCombo, poisonSkills);
		pushAll(sortedCombo, bulbSkills);
		
		//debug("unsorted combo : " + combo);
		//debug("sorted combo : " + sortedCombo);
		return sortedCombo;
}

/*************************************************************************/
// For each combo this function calls calculateComboScore
// It then stores the score and the key associated to the combo in comboScores

// comboScores[0] = [scoreFirstCombo, keyFirstCombo];
// comboScores[1] = [scoreSecondCombo, keySecondCombo];
// comboScores[n] = [...];
 
function calculateCombosScore(){

	ourLeekCarac = getLeekCarac(ourLeekID);
	enemyLeekCarac = getLeekCarac(enemyID);

	// We will analyze a combo not a trajectory 
	isCombo = true;

	for (var key : var combo in sortedCombosList){
		
		ourLeekCaracTemp = ourLeekCarac;
		enemyLeekCaracTemp = enemyLeekCarac;

		// calculateComboScore function calculates the score of the "analyzedTrajectory" global variable 
		// Therefore, we fill a "analyzedTrajectory" with the current combo
		analyzedTrajectory[SKILL] = combo;
		calculateComboScore();

		var scoreAndKey = [];
		scoreAndKey[TOTAL_SCORE] = analyzedTrajectory[TOTAL_SCORE];
		scoreAndKey[KEY] = key;

		push(comboScores, scoreAndKey);
	}
}


/*************************************************************************/
// This function calls the score functions associated to each skills
// The input of this function is the "analyzedTrajectory" global variable 
function calculateComboScore(){
	var score = 0;
	skillKey = 0;
	for (var skill in analyzedTrajectory[SKILL]){
		// this is the call to the function. Check the top of the file. You're welcome ;)
		var skillScore = skills[skill][SCORE_FUNCTION]();

		// stores the score of the skill
		push(analyzedTrajectory[SCORE], skillScore);

		// Add the score of the skill to the total score of the trajectory
		analyzedTrajectory[TOTAL_SCORE] += skillScore;

		skillKey++;
	}
}


/*************************************************************************/
// This function sorts all the combo by score 

function sortCombosByScore(){
	// sort costs
	sortedComboScores = arraySort(comboScores, function(comboScore1, comboScore2) {
    	return comboScore2[TOTAL_SCORE] - comboScore1[TOTAL_SCORE];
	});
}


// A trajectory is an array containing:
// * the list of the skills that will be used (it is a combo)
// * the cell from where the skill will be casted
// * the MP used to go to this cell
// * the cell targeted by the skill
// * the score of the combo
//
// [[cell1, cell2, ...], [skill1, skill2, ...], [targetCell1, targetCell2, ...] [MPUsed1, MPUsed2, ...], score]
//
//                       +---------------------------------------------------------------------------------------------------------------------------------------------------------+
//             nbOp +----| generate_trajectories                                                                                                                                   |
//                       |                                                                                                                                                         |
//                       |             +--------------------+                    +-------------------+                                                                             |
//          enemySkills  |             |                    |     dangerMap      |                   | safeNodes                                                                   |
//                  +------------------>  fill_danger_map   +-------------------->  fill_safe_nodes  +-------+                                                                     |
//                       |             |                    |                    |                   |       |                                                                     |
//              enemyID  |             |                    |                    +-------------------+       |                                                                     |
//                  +------------------>                    |                                                |                                                                     |
//                       |             |                    |                                                |                                                                     |
//                  map  |             |                    |                                                |                                                                     |
//                  +------------------>                    |                                                |                                                                     |
//                       |             |                    |                                                |                                                                     |
//                       |             +--------------------+                                                |                                                                     |
//                       |                                                                                   |                                                                     |
//                       |   +-------------------------------------------------------------------------------+                                                                     |
//                       |   |                                                                                                                                                     |
//                       |   |                                                                                                                                                     |
//                       |   |         +-------------------------------------------+                                                                                               |
//                       |   |         |  generate_movement_only_trajectories      |                                                                                               |
//                       |   |         |                                           |                                                                                               |
//                       |   |         |    * generate_escape_only_trajectory      |                                                                                               |
//                       |   +--------->    * generate_go_toward_enemy_trajectory  +-------------------------------------------------------------------------------------------+   |
//                       |   |         |    * ...                                  |                                                                                           |   |
//                       |   |         |                                           |                                                                                           |   |
//                       |   |         +-------------------------------------------+                                                                                           |   |
//                       |   |                                                                                                                                                 |   |
//                       |   |         +---------------------------------------------------------------------------------------------------------------------------------+     |   |
//                       |   |         |                                                                                                                                 |     |   | allTrajectories
//                       |   |         |         +---------------------+              +-----------------------------------------------------------------------------+    |     +-------------------->
//                       |   |         |   combo |                     | actionNodes  | generate_trajectories_from_combo                                            |    |     |   |
//                       |   |         |     +--->  fill_action_nodes  +-------------->                                                                             |    |     |   |
//                       |   |         |         |                     |              |                                                                             |    |     |   |
//                       |   |         |         +---------------------+              |                                                                             |    |     |   |
//                       |   +--------->                                              | +------------------------------+            +----------------------------+  |    |     |   |
//                       |             |                                combo         | |                              |trajectories|                            |  |    |     |   |
//                       |             |                                   +----------> | generate_basic_trajectories  +--->   +----> generate_escape_trajectory |  |    +-----+   |
//                       |             |                                              | |                              |            |                            |  |    |         |
//     sortedCombosList  |             |                                              | |                              |result      +----------------------------+  |    |         |
//                 +------------------->                                              | |                              +--->                                        |    |         |
//                       |             |                                              | +------------------------------+                                            |    |         |
//    sortedComboScores  |             |                                              |                                                                             |    |         |
//                 +------------------->                                              |                                                                             |    |         |
//                       |             |                                              +-----------------------------------------------------------------------------+    |         |
//                       |             |                                                                                                                                 |         |
//                       |             +---------------------------------------------------------------------------------------------------------------------------------+         |
//                       |                                                                                                                                                         |
//                       +---------------------------------------------------------------------------------------------------------------------------------------------------------+


function generateGroundScoreMap(){
    // generate the groundScoreMap
    // The point of this map is to attribute a lower score to dead-ends
    // Initiate each cell of the map with a 0 score
    for (var i = 0; i <= 612; i++){
    	groundScoreMap[i] = 0;
    }

    // retrieve the obstacles. For each obstacle we will reduce the score of the adjacent cells by 1
    // note: the score of the cells that are obstacles are not well handled, but we don't care since we will never use them
    var obstacles = getObstacles();
    for (var obstacle in obstacles){
    	var adjacentCells = getArea(1, obstacle);
    	if (adjacentCells !== null){
    		for (var adjacentCell in adjacentCells){
    			groundScoreMap[adjacentCell] -= 1;
    		}
    	}
    }

    // Reduce the score of the top and bottom row
    for (var i = 1; i <= 16; i++){
    	groundScoreMap[i] -= 2;
    	groundScoreMap[i + 595] -= 2;
    }

    // Reduce the score of the left and right column
    for (var i = 35; i <= 560; i+=35){
    	groundScoreMap[i] -= 2;
    	groundScoreMap[i + 17] -= 2;
    }

    // Reduce the score of the corners 
    groundScoreMap[0] -= 3;
    groundScoreMap[17] -= 3;
    groundScoreMap[595] -= 3;
    groundScoreMap[612] -= 3;


    // Display the groundScoreMap for debug purpose 
    for (var i = 0; i <= 612; i++){
    	if (!isObstacle(i)){
    		mark(i, getColor(255, (255 + groundScoreMap[i] * 55), (255 + groundScoreMap[i] * 55)));
    	}
    }

    pause();
}

function generateEntityScoreMap(){

	// copy of the groundScoreMap
	entityScoreMap = groundScoreMap;

	getCell(enemyID);
}
/*************************************************************************/
// This function is used to calculate a maximum of the trajectory from the combos with the best score
// without using more operation than the maximum operation limit
// operationThreshold: TO BE IMPROVED
function generate_trajectories(){
	var operationThreshold = 3000000;

	var nbOp = getOperations();
	fill_danger_map(true);
	//debug("danger map: " + dangerMap);
	debug("nb instruct fill danger map : " + (getOperations() - nbOp));
	fill_safe_nodes(true);
	generate_movement_only_trajectories();
	nbComboUsed = 1;

	for (var comboScore in sortedComboScores){
		//debug("combo: " + sortedCombosList[comboScore[KEY]]);
		fill_action_nodes(sortedCombosList[comboScore[KEY]]);
		//debug("action Nodes: " + actionNodes);
		generate_trajectories_from_combo(sortedCombosList[comboScore[KEY]]);
		nbComboUsed++;

		if (OPERATIONS_LIMIT - getOperations() < operationThreshold){
			//debug("remaing operation inferior to " + operationThreshold);			
			break;
		}
	}
	//debug((nbComboUsed - 1) +" combos has been used to calculate the trajectories"  );
}

/*************************************************************************/
// This function is used to generate movement only trajectories
// generate_go_toward_enemy_trajectory() TO BE IMPROVED
function generate_movement_only_trajectories(){
	generate_escape_only_trajectory();
	//generate_go_toward_enemy_trajectory()
}


/*************************************************************************/
// This function is used to fill the danger map based on 
//  * the chips and weapons of the enemy leek
//  * the chips of the enemy bulbs : TO BE IMPROVED
// Many things can be improved here: TO BE IMPROVED
function fill_danger_map(show){
	
	// retrieve all the cell where our leek can go
	var area = getArea(getMP(), getCell());
	if (show == true){	
		for (var cell in area){
			mark(cell, getColor(200,25,150));
		}
	}

	// Choose which skills should be analyzed
	// this is a data loss, but it is required to limit the number of operations

	// variable used to store the skills that will be analyzed
	var enemySkills = [];

	// only analyze the weapon currently being equiped
	if (getWeapon(enemyID) != null )
		push(enemySkills, getWeapon(enemyID));

	// variables used to find the chip that deals the most damage
	var maxDamage = 0;
	var chosenChip = null;

	// retrieve the chips that deals damages
	for (var chip in getChips(enemyID)){	
		// if the chip doesn't deal damages, drop it 
		if (skills[chip][TYPE] != DAMAGE && skills[chip][TYPE] != POISON){
			continue;
		}
		var damage = getObjectDamage(chip, getStrength(enemyID));
		if ((damage["Max"] + damage["Min"] / 2) > maxDamage){
			chosenChip = chip;
			maxDamage = (damage["Max"] + damage["Min"] / 2);
		}
	}

	if (chosenChip != null){
		push(enemySkills, chosenChip);
	}

	if (isEmpty(enemySkills) == false ){
		// for each cell the leek can reach, check if the cell can be targeted by the chosen enemy skills
		// There is a lot of data loss here, we have a maximum of 1 skill stored by cell : TO BE IMPROVED 
		for (var key : var cell in area){
			var nbOp = getOperations();
			for (var skill in enemySkills){
					// if the skill is a chip, check its cooldown. If it is on cooldown, don't bother calculate the danger.
					if (isChip(skill) && getCooldown(skill, enemyID) != 0){
						debug("on cooldownn");
						continue;
					}
					if (dangerMap[cell] == null){
						canUseIfMoving(skill, cell, enemyID, false,  false);
					}
				}
		//debug("cell: " + cell + ", nb instruct " + key + "/" + count(area)+ ": " + (getOperations() - nbOp));
		}
	}	
	//debug("danger map: "+ dangerMap);
}

/*************************************************************************/
// This function is used to find the trajectory that with the best score
// This function doesn't handle chips cast on allies (to be improved)
function fill_action_nodes(combo){
	for (var skill in combo){
		if (skill > 1000)
			skill -= 1000;

		if (getType() == ENTITY_LEEK || getType() == ENTITY_BULB){	
			if (skills[skill][TYPE] == DEBUFF || skills[skill][TYPE] == DAMAGE || skills[skill][TYPE] == POISON){

				if (processedActions[skill] === null){
					// debug("fill_action_nodes(): fill the action map with : " + skill);
					canUseIfMoving(skill,  getCell(enemyID),  ourLeekID, true,  false);
					processedActions[skill] = true;
				}
			}
		}
		else {
			debug("fill_action_nodes: case not handled");
		}
	}
}


/*************************************************************************/
// This function is used to generate the different trajectories of a combo
// There are trajectories for:
//  * full combo + mvmt
//  * full combo
//  * full indirect combo + mvmt
//  * full indirect combo
// A trajectory can be full (all the skills can be used) or partial

// A trajectory is an array : 
// [	[cell1, cell2, ...], 
//		[skill1, skill2, ...], 
//		[targetCell1, targetCell2, ...],
//		[MPUsed1, MPUsed2, ...], 
//		[score1, score2, ...], 
//		totalScore
// ]
// The number of MP used to calculate the trajectory considers the skills that increases the number of MP (not implemented yet) TO BE IMPROVED

function generate_trajectories_from_combo(combo){
	trajectories = [];

	var result = generate_basic_trajectories(combo);

	if (result[DIRECT] == true && result[INDIRECT] == true){
		generate_escape_trajectory(trajectories[0]);
		generate_escape_trajectory(trajectories[1]);
	}
	else if (result[DIRECT] == true && result[INDIRECT] == false){
		generate_escape_trajectory(trajectories[0]);
	}
	else if (result[DIRECT] == false && result[INDIRECT] == true){
		generate_escape_trajectory(trajectories[0]);
	}	
	else if (result[DIRECT] == false && result[INDIRECT] == false){
		//nothing to be done in that case
	}
	else {
		debug("generate_escape_trajectories unhandled case");
	}

	//debug("combo: " + combo);
	//debug("trajectories: " + trajectories);
	pushAll(allTrajectories, trajectories);
}

/*************************************************************************/
// This function is used to generate a trajectory from a combo
// TO BE IMPROVED : The target are always ourself or the enemy leek, we don't handle cast on allies right now
// TO BE IMPROVED : we use getpath each time we want to summon a bulb
function generate_basic_trajectory(isItDirect, combo){

	var trajectory = [];
	trajectory[SKILL] = [];
	trajectory[CELLS] = [];
	trajectory[MVMP] = [];
	trajectory[TARGET_CELL] = [];
	trajectory[SCORE] = [];
	trajectory[TOTAL_SCORE] = 0;	

	var	nbSkillInTrajectory = 0;
	//debug("indirect combo: " + combo);
	// generate indirect trajectories without escape
	for (var key: var skill in combo){
		var nextNodeResult = [];
		// if the skill requires a mouvment to be executed
		if (skills[skill][TYPE] == DEBUFF || skills[skill][TYPE] == DAMAGE || skills[skill][TYPE] == POISON){

			if (nbSkillInTrajectory == 0){
				nextNodeResult = find_next_node(skill%1000, getCell(), isItDirect, getMP());
			}
			else {
				nextNodeResult = find_next_node(skill%1000, trajectory[CELLS][key - 1], isItDirect, (getMP() - sum(trajectory[MVMP])));
			}
			// if a cell can be reached then save it in the trajectory
			if (nextNodeResult[TYPE] == true){
				push(trajectory[SKILL], skill);
				push(trajectory[CELLS], nextNodeResult[CELLS]);
				push(trajectory[MVMP], nextNodeResult[MVMP]);
				push(trajectory[TARGET_CELL], nextNodeResult[TARGET_CELL]);
				nbSkillInTrajectory++;

			}
		}
		// if the skill does not require a mouvment to be executed
		else {
			// if the skill is a summoning, we need to find the target cell differently
			if (skills[skill][TYPE] == BULB){
				// debug("generate_basic_trajectories(): summoning cell not handled yet");

				// TO BE IMPROVED: 
				// we will summon the bulb at the place we are.
				// So, we try to find a path toward the enemy
				// if there is one, we summon the bulb

				// We find how much distance we must travell
				var distance = 1;
				if (skill == CHIP_FIRE_BULB){
					distance = 2;
				}
				// We find the path toward the enemy
				var path;
				if (nbSkillInTrajectory == 0){
					path = getPath(getCell(), getCell(enemyID));
				}
				else {
					path = getPath(trajectory[CELLS][nbSkillInTrajectory - 1], getCell(enemyID));
				}
					
				if (path !==  null){
					// If there is a long enough path, then save it in the trajectory
					if (count(path) >= distance + 2){
						if (nbSkillInTrajectory == 0){
							push(trajectory[SKILL], skill);
							push(trajectory[CELLS], path[distance]);
							push(trajectory[MVMP], 0);
							push(trajectory[TARGET_CELL], getCell());
							nbSkillInTrajectory++;
						}
						else{
							push(trajectory[SKILL], skill);
							push(trajectory[CELLS], path[distance]);
							push(trajectory[MVMP], 0);
							push(trajectory[TARGET_CELL], trajectory[CELLS][nbSkillInTrajectory - 1]);
							nbSkillInTrajectory++;
						}
					}
				}
			}
			else {
				if (nbSkillInTrajectory == 0){
					push(trajectory[SKILL], skill);
					push(trajectory[CELLS], getCell());
					push(trajectory[MVMP], 0);
					push(trajectory[TARGET_CELL], getCell());
					nbSkillInTrajectory++;
				}
				else{
					push(trajectory[SKILL], skill);
					push(trajectory[CELLS], trajectory[CELLS][nbSkillInTrajectory - 1]);
					push(trajectory[MVMP], 0);
					push(trajectory[TARGET_CELL], trajectory[CELLS][nbSkillInTrajectory - 1]);
					nbSkillInTrajectory++;
				}
			}

		}
	}

	return trajectory;
}

/*************************************************************************/
// This function is used to generate a direct and an indirect trajectory from a combo
// Return an array of boolean to know if the direct and indirect trajectories have been 
// generated 
// TO BE IMPROVED : copy the beginning of "direct" in "indirect" until a skill has AOE
function generate_basic_trajectories(combo){

	var direct = generate_basic_trajectory(true, combo);
	var indirect = generate_basic_trajectory(false, combo);

	var result = [false, false];

	// Check if there is at least one skill used in the trajectories 
	if (!isEmpty(direct[SKILL])){
		push(trajectories, direct);
		result[DIRECT] = true;
	}
	// Check if there is at least one skill used in the trajectories 
	if (!isEmpty(indirect[SKILL])){
		push(trajectories, indirect);
		result[INDIRECT] = true;
	}
	//debug("trajectories: "+ trajectories);
	return result;
}

/*************************************************************************/
// This function is used to generate the direct and indirect escape trajectories of a combo
// If there is not enough MP to go to a safe point, discard the last skills one by one until there is enough MP
function generate_escape_trajectory(trajectory){

	var stop = false;

	while (stop == false){

		var skillNumber = count(trajectory[SKILL]);
		var nextNodeResult = find_next_node(MOVE, trajectory[CELLS][skillNumber - 1], false, (getMP() - sum(trajectory[MVMP])));
		//debug ("mp available: " + (getMP() - sum(trajectory[MVMP])) + ", nextNodeResult: "+ nextNodeResult);
		if (nextNodeResult[TYPE] == true ){
			var newTrajectory = trajectory;	

			push(newTrajectory[SKILL], MOVE);
			push(newTrajectory[CELLS], nextNodeResult[CELLS]);
			push(newTrajectory[MVMP], nextNodeResult[MVMP]);
			push(newTrajectory[TARGET_CELL], nextNodeResult[TARGET_CELL]);

			push(allTrajectories, newTrajectory);
			stop = true;
		}
		else {
			pop(trajectory[SKILL]);
			pop(trajectory[CELLS]);
			pop(trajectory[MVMP]);
			pop(trajectory[TARGET_CELL]);
			if (skillNumber == 1)
				stop = true;
		}
	}
}


/*************************************************************************/
// This function is used to generate an escape only trajectory (without combo)

function generate_escape_only_trajectory(){
	var nextNodeResult = find_next_node(MOVE, getCell(), false, getMP());
	if (nextNodeResult[TYPE] == true ){
		var newTrajectory = [];	
		newTrajectory[SKILL] = [];
		newTrajectory[CELLS] = [];
		newTrajectory[MVMP] = [];
		newTrajectory[TARGET_CELL] = [];
		newTrajectory[SCORE] = [];
		newTrajectory[TOTAL_SCORE] = 0;

		push(newTrajectory[SKILL], MOVE);
		push(newTrajectory[CELLS], nextNodeResult[CELLS]);
		push(newTrajectory[MVMP], nextNodeResult[MVMP]);
		push(newTrajectory[TARGET_CELL], nextNodeResult[TARGET_CELL]);

		push(allTrajectories, newTrajectory);
	}
}

/*************************************************************************/
// This function is used to find the next node
// The chosen node is the closest node
// returns an array [cellFound, cell, MPused, targetCell]

function find_next_node(skill, currentCell, direct, mpAvailable){
    var nodes = [];
    // if you want to find a safe place then look in the safe nodes
    if (skill == MOVE){
            nodes = safeNodes;
    }
    // otherwise look in the action nodes
    else {
        if (skill > 1000){
                skill -= 1000;
        }      
        nodes = actionNodes[skill];
    }

    var result = [];
    result[TYPE] = false;
    result[MVMP] = 1000;

	//debug("mpAvailable: " + mpAvailable);
	//debug("nodes: "+ nodes);

    for (var node in nodes){
		// Check if this node can do a direct hit 
		if (direct && node["TARGET_CELL"] != node["INDIRECT_CELL"]){
			continue;
		}

		var pathLength = getPathLength(currentCell, node["CELL"]);
		//debug("pathLength: " + pathLength);
		if (pathLength != null){
			if (pathLength < result[MVMP] && pathLength <= mpAvailable){
				if (skill == MOVE){
					result[TARGET_CELL] = 0;
				}
				else {
					result[TARGET_CELL] = node["INDIRECT_CELL"];
				}
				result[MVMP] = pathLength;
				result[CELLS] = node["CELL"];
				result[TYPE] = true;

				if (pathLength == 0){
					break;
				}
			}
		}
	}

	return result;
}

/*************************************************************************/
// This function is used to find the best trajectory
// Only the key of the best trajectory is stored
function find_best_trajectory_score(){

	var bestScore = -999999999;
	if (isEmpty(allTrajectories) == true)
		debug("find_best_trajectory_score(): allTrajectories[] is empty !");

	for (var key: var trajectory in allTrajectories){
		if (trajectory[TOTAL_SCORE] > bestScore){
			bestScore = trajectory[TOTAL_SCORE];
			bestTrajectoryKey = key;
		}
	}
	
	//debug("best trajectory score: " + bestScore);
}


/*************************************************************************/
// This function is used fill the action sequence with the best trajectory
// TO BE IMPROVED: we don't handle only equiping a weapon
function fill_action_sequence(){

	for (var key : var skill in allTrajectories[bestTrajectoryKey][SKILL]){
		//move to cell
		actionSequence[actionTotal] = [];
		actionSequence[actionTotal][0] = MOVE_TO_CELL;	
		actionSequence[actionTotal][1] = allTrajectories[bestTrajectoryKey][CELLS][key];			
		actionTotal++;

        if (skill != MOVE){
        	// discard the skills with a negativ or null score 
			// (for example if antidote does not remove some poison we want to keep it for later)
        	if (allTrajectories[bestTrajectoryKey][SCORE][key] > 0){
                //equip weapon if required
                if (skill > 1000){
                        skill -= 1000;
                        actionSequence[actionTotal] = [];
                        actionSequence[actionTotal][0] = EQUIP_WEAPON;
                        actionSequence[actionTotal][1] = skill;
                        actionTotal++;
                }

                //use skill
                actionSequence[actionTotal] = [];
                actionSequence[actionTotal][0] = USE_OBJECT;
                actionSequence[actionTotal][1] = skill;
                actionSequence[actionTotal][2] = allTrajectories[bestTrajectoryKey][TARGET_CELL][key];

                actionTotal++;
        	}
        	else{
        		debug("fill_action_sequence(): skills : " + allTrajectories[bestTrajectoryKey][SKILL]);
        		debug("fill_action_sequence(): discarded skill: " + allTrajectories[bestTrajectoryKey][SKILL][key]);
        	}
        }
	}
}

/*************************************************************************/
// This function is used fill the safeNodes with untargetable cell 
// TO BE IMPROVED : currently we only consider the cell containing no enemy skill, when we should quantify the danger
function fill_safe_nodes(show){
    var area = getArea(getMP(), getCell());

    //debug("dangerMap: " + dangerMap);
    for (var cell in area){
    	//debug("dangerMap[" + cell + "] : " + dangerMap[cell]);
        if (dangerMap[cell] == null){
        		if (show == true) {
        			mark(cell, COLOR_GREEN);
        		}
                var node = [];
                node["CELL"] = cell;
                push(safeNodes, node);
        }
    }
    //debug("safeNodes: " + safeNodes);
}


/*************************************************************************/
// This function is used to calculate the score of the trajectories
// The score is determined:
//  * with the score function (the one used to calculate the combo score)
//  * with the damage done by the enemies on the last cell 

function calculate_trajectories_score(){
	//debug("calculate_trajectories_score()");
	if (isEmpty(allTrajectories) == true )
		debug("calculate_trajectories_score(): allTrajectories[] is empty");

	ourLeekCarac = getLeekCarac(ourLeekID);
	enemyLeekCarac = getLeekCarac(enemyID);

	// We will analyze a trajectory not a combo (basically it means, that we consider indirect cells)
	isCombo = false;

	// for each trajectory, calculate its score:
	//  * the score based on the skills
	//  * plus the score based on the final cell
	for(var key: var trajectory in allTrajectories){
		//debug("key: "+ key + ", trajectory: " + trajectory);
		//debug("trajectory[SKILL]: " + trajectory[SKILL]);
		ourLeekCaracTemp = ourLeekCarac;
		enemyLeekCaracTemp = enemyLeekCarac;

		// calculateComboScore function calculates the score of the "analyzedTrajectory" global variable 
		// Therefore, we fill "analyzedTrajectory" with the current trajectory
		analyzedTrajectory = trajectory;
		calculateComboScore();

		// debug test
		if (trajectory[CELLS][count(trajectory[CELLS])-1] === null)
			debug("calculate_trajectories_score: key: " + key + ", trajectory: " + trajectory);
		// decreases the score depending on the damage dealt by the enemies
		analyzedTrajectory[TOTAL_SCORE] += calculatePositionScore(analyzedTrajectory[CELLS][count(analyzedTrajectory[CELLS])-1]);
		
		//debug("score : " + score);
		// Currently the score of the trajectory is only stored in "analyzedTrajectory"
		// Therefore, stores the results in allTrajectories 
		allTrajectories[key][SCORE] = analyzedTrajectory[SCORE];
		allTrajectories[key][TOTAL_SCORE] = analyzedTrajectory[TOTAL_SCORE];
	}
}


