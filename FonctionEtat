include("GlobalVar");
include("Utilitaires");
include("Strategy");
include("IA");

function initGameFunction(){
	//debug("init game state");

	var enemyList = getAliveEnemies();
	for (var i = 0; i < count(enemyList) && enemyID == null; i++){
		if (getType(enemyList[i]) == ENTITY_LEEK){
			enemyID = enemyList[i];
		}
	}

	if (enemyID == null){
		debug("no enemy selected");
	}
	ourLeekID = getLeek();

	etat = INIT_TURN;
}

function initTurnFunction(){
	//debug("init turn state");	

	//raz de la liste des actions à effectuer
	actionSequence = [];
	currentAction = 0;
	actionTotal = 0;
	TPTotal = 0;
	/*	
	var weCanShootifMoving = false;
	var weCanUseChipIfMoving = false;
	if(weaponID != null) {
		
		weCanShootifMoving = canUseIfMoving(getLeek(), getCell(enemyID));
		if (canUseIfMoving(CHIP_ROCK, getLeek(), getCell(enemyID)) != -1 || getMP() >= getChipMinRange(CHIP_ROCK))
			weCanUseChipIfMoving = true;
	}
		
	var enemyCanShootNextTurn = canUseIfMoving(enemyID, getCell());
	//var enemyCanUseChipNextTurn = canUseIfMoving(CHIP_SPARK, enemyID, getCell());
	if(enemyID == null || isDead(enemyID))
		enemyID = getNearestEnemy();
		
	minDamageEnemy = 0;
	maxDamageEnemy = 0;
	var minDamage = 0;
	var maxDamage = 0;
	weaponID = getWeapon();
	strengthEnemy = getStrength(enemyID);
	enemyWeapon = getWeapon(enemyID);
	enemyMaxWeaponRange = getWeaponMaxRange(enemyWeapon);
	
	if(getWeapon(enemyID) != null) {
		for(var damage in getDamage(getWeapon(enemyID), strengthEnemy)) {
			minDamageEnemy += calculateDamage(getLeek(), damage["MIN"]);
			maxDamageEnemy += calculateDamage(getLeek(), damage["MAX"]);
		}
	}
	debug("minDamage ennemi : "+minDamageEnemy);
	debug("maxDamage ennemi : "+maxDamageEnemy);
	
	if(weaponID != WEAPON_SHOTGUN) {
		if(weCanUseChipIfMoving) {
			for(var damage in getDamage(CHIP_ROCK, getStrength())) {
					minDamage += calculateDamage(getLeek(), damage["MIN"]);
					maxDamage += calculateDamage(getLeek(), damage["MAX"]);
				}	
		}
		if(weCanShootifMoving) {
			if(weaponID != null) {
				for(var i = 0; i<getTP()/getWeaponCost(weaponID); i++) {
					for(var damage in getDamage(weaponID, getStrength())) {
						minDamage += calculateDamage(getLeek(), damage["MIN"]);
						maxDamage += calculateDamage(getLeek(), damage["MAX"]);
					}
				}
			}
		}
	} else {
		for(var i = 0; i<getTP()/getWeaponCost(weaponID); i++) {
			for(var damage in getDamage(weaponID, getStrength())) {
				minDamage += calculateDamage(getLeek(), damage["MIN"]);
				maxDamage += calculateDamage(getLeek(), damage["MAX"]);
			}
		}
	}
	
	debug("minDamage : "+minDamage);
	debug("maxDamage : "+maxDamage);
	
	if(minDamage >= getLife(enemyID)*0.9 && maxDamage > getLife(enemyID))
		etat = ATTACK;
	else
		etat = BUFF;

	*/
	etat = STRATEGY_CHOICE;
}

function strategyChoiceFunction(){
	//debug("strategy choice state"); 

	if (getType() == ENTITY_LEEK){
		leekStrategyChoice();
	}
	else {
		punnyBulbStrategyChoice();
	}

	etat = ACTION_CHOICE;	
}


function actionChoiceFunction(){
	//debug("action choice state"); 

	if (currentAction < actionTotal){
		etat = actionSequence[currentAction];
		currentAction++;
	}
	else {
		etat = LAST_ACTION;
	}
	
}

function equipShotgunFunction(){
	debug("equip shotgun state"); 	
	setWeapon(WEAPON_SHOTGUN); // Attention : coûte 1 PT
	weaponID = getWeapon();

	etat = ACTION_CHOICE;
}

function equipMagnumFunction(){
	debug("equip magnum state"); 	
	setWeapon(WEAPON_MAGNUM); // Attention : coûte 1 PT
	weaponID = getWeapon();

	etat = ACTION_CHOICE;
}


function equipGrenadeLauncherFunction(){
	debug("equip grenadeLauncher state"); 	
	setWeapon(WEAPON_GRENADE_LAUNCHER); // Attention : coûte 1 PT
	weaponID = getWeapon();

	etat = ACTION_CHOICE;
}

function moveTowardEnemyFunction (){
	debug("move toward enemy state"); 	
	moveToward(enemyID);

	etat = ACTION_CHOICE;
}

function moveAwayFromEnemyFunction(){
	debug("move away from enemy state"); 	
	moveAwayFrom(enemyID);

	etat = ACTION_CHOICE;
}

function summonPunnyBulbFunction(){
	debug("use punny bulb chip state"); 	
	
	var summoningCell = getCell();
	moveToward(enemyID, 1);
	summon(CHIP_PUNY_BULB, summoningCell, stateMachine);

	etat = ACTION_CHOICE;
}

function moveTowardLeekFunction(){
	debug("move toward leek state"); 	

	moveToward(ourLeekID);

	etat = ACTION_CHOICE;	
}

function moveToWeaponRangeFunction(){
	debug("move to weapon range state"); 	

	moveTowardCell(canUseIfMoving(weaponID, getCell(enemyID), ourLeekID));

	etat = ACTION_CHOICE;
}

function moveToLightningRangeFunction(){
	debug("move to lightning range state"); 	

	moveTowardCell(canUseIfMoving(CHIP_LIGHTNING, getCell(enemyID), ourLeekID));

	etat = ACTION_CHOICE;
}

function moveToStalactiteRangeFunction(){
	debug("move to stalactite range state"); 	

	moveTowardCell(canUseIfMoving(CHIP_STALACTITE, getCell(enemyID), ourLeekID));

	etat = ACTION_CHOICE;

}

function moveToSparkRangeFunction(){
	debug("move to spark range state"); 	

	moveTowardCell(canUseIfMoving(CHIP_SPARK, getCell(enemyID), ourLeekID));

	etat = ACTION_CHOICE;

}
function useWeaponFunction(){
	debug("use weapon state"); 	

	useWeapon(enemyID);

	etat = ACTION_CHOICE;	
}

function useBandageFunction(){
	debug("use bandage state");

	useChip(CHIP_BANDAGE, ourLeekID);

	etat = ACTION_CHOICE;	
}

function useStalactiteFunction(){
	debug("use stalactite state");

	useChip(CHIP_STALACTITE, enemyID);

	etat = ACTION_CHOICE;
}

function useRockFunction(){
	debug("use rock state");

	useChip(CHIP_ROCK, enemyID);

	etat = ACTION_CHOICE;
}

function usePebbleFunction(){
	debug("use pebble state");

	useChip(CHIP_PEBBLE, enemyID);

	etat = ACTION_CHOICE;
}


function useHelmetFunction(){
	debug("use helmet state");

	useChip(CHIP_HELMET, ourLeekID);

	etat = ACTION_CHOICE;
}

function useShieldFunction(){
	debug("use SHIELD state");

	useChip(CHIP_SHIELD, ourLeekID);

	etat = ACTION_CHOICE;
}

function useFortressFunction(){
	debug("use fortress state");

	useChip(CHIP_FORTRESS, ourLeekID);

	etat = ACTION_CHOICE;
}

function useRampartFunction(){
	debug("use rampart state");

	useChip(CHIP_RAMPART, ourLeekID);

	etat = ACTION_CHOICE;
}

function useProteinFunction(){
	debug("use protein state");

	useChip(CHIP_PROTEIN, ourLeekID);

	etat = ACTION_CHOICE;
}

function useSparkFunction(){
	debug("use spark state");

	useChip(CHIP_SPARK, enemyID);

	etat = ACTION_CHOICE;
}

function useLightningFunction(){
	debug("use lightning state");

	useChip(CHIP_LIGHTNING, enemyID);

	etat = ACTION_CHOICE;
}



/*
function strategyMoveToLimitRange(){
	debug ("strategy move to limit range");
	var i = 0;
	var pathToEnemy = getPath(getCell(), getCell(enemyID));
	while (getMP() > 0 && canUseIfMoving(CHIP_ROCK, enemyID, pathToEnemy[i]) == -1){
		moveToward(enemyID,1);
		i++;
	}
	etat = END;
}
*/


/*
//kiting
function strategyKitingFunction(){
	debug("strategy Kiting");
	while (!canUseChipFromCellToCell(CHIP_SPARK, getCell(), getCell(enemyID)) && getMP() > 0){
		moveToward(enemyID, 1);
	}
	
	while (getTP() >= getChipCost(CHIP_SPARK) && canUseChipFromCellToCell(CHIP_SPARK, getCell(), getCell(enemyID))){
		useChip(CHIP_SPARK, enemyID);
	}
	
	moveAwayFrom(enemyID, getMP());
	
	etat = END;
}
*/





function lastActionFunction() {

	if (isDead(enemyID)){say ("Reviens gamin !! C'était pour rire ");}
	else if (getTurn() == 2){
		if (getType() == ENTITY_LEEK){
			say("Une larme de gin. Une rivière de tonic... Et ensuite la p'tite victime");
		}
		else {
			say("Pigeon, oiseau à la grise robe, dans l'enfer des villes, à mon regard tu te dérobes...Tu es vraiment le plus agile. ");
		}
	}

	etat = END_TURN;
}

