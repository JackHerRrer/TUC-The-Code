include("GlobalVar");
include("Utilitaires");
include("Strategy");
include("IA");

function initGameFunction(){
	//debug("init game state");

	var enemyList = getAliveEnemies();
	for (var i = 0; i < count(enemyList) && enemyID == null; i++){
		if (getType(enemyList[i]) == ENTITY_LEEK){
			enemyID = enemyList[i];
		}
	}

	if (enemyID == null){
		debug("no enemy selected");
	}
	ourLeekID = getLeek();

	etat = INIT_TURN;
}

function initTurnFunction(){
	//debug("init turn state");	

	//raz de la liste des actions à effectuer
	actionSequence = [];
	currentAction = 0;
	actionTotal = 0;
	TPTotal = 0;
	MPTotal = 0;

	actionMap = [];
	dangerMap = [];
	movingArea = [];

	etat = STRATEGY_CHOICE;
}

function strategyChoiceFunction(){
	//debug("strategy choice state"); 

	if (getType() == ENTITY_LEEK){
		leekStrategyChoice();
	}
	else {
		punnyBulbStrategyChoice();
	}

	// display the list of the chosen actions
	debug("******************************");
	for (var i = 0; i < actionTotal; i++){
		if (actionSequence[i][0] != USE_OBJECT){
			debug(actionSequence[i][0]);
		}
		else {
			debug(actionSequence[i][0] + " : " + actionSequence[i][1]);
		}
	}
	debug("TP total : "+ TPTotal);
	debug("******************************\n");

	etat = ACTION_CHOICE;	
}


function actionChoiceFunction(){
	//debug("action choice state"); 

	if (currentAction < actionTotal){
		etat = actionSequence[currentAction][0];		
		// As currentAction is incremented before the action happens, to get the right parameters of the action, currentAction - 1 needs to be used
		currentAction++;
	}
	else {
		etat = LAST_ACTION;
	}
	
}

function equipShotgunFunction(){
	debug("equip shotgun state"); 	
	setWeapon(WEAPON_SHOTGUN); // Attention : coûte 1 PT
	weaponID = getWeapon();

	etat = ACTION_CHOICE;
}

function equipMagnumFunction(){
	debug("equip magnum state"); 	
	setWeapon(WEAPON_MAGNUM); // Attention : coûte 1 PT
	weaponID = getWeapon();

	etat = ACTION_CHOICE;
}


function equipGrenadeLauncherFunction(){
	debug("equip grenadeLauncher state"); 	
	setWeapon(WEAPON_GRENADE_LAUNCHER); // Attention : coûte 1 PT
	weaponID = getWeapon();

	etat = ACTION_CHOICE;
}

function moveTowardEnemyFunction (){
	debug("move toward enemy state"); 	
	moveToward(enemyID);

	etat = ACTION_CHOICE;
}

function moveAwayFromEnemyFunction(){
	debug("move away from enemy state"); 	
	
	var closestCell;
	var shortestPath=-1;
	for (var cell in movingArea){
		if (dangerMap[cell] == null){
			mark(cell, getColor(20, 235, 20));
			var pathLength = getPathLength(getCell(), cell);
			if (pathLength <= getMP()){
				if (shortestPath == -1 || pathLength < shortestPath){
					shortestPath = pathLength;
					closestCell = cell;
				}
			}
		}

	}

	if (shortestPath != -1){
		moveTowardCell(closestCell);
	}
	else {
		moveAwayFrom(enemyID);
	}

	etat = LAST_ACTION;
}

function summonPunnyBulbFunction(){
	debug("summon punny bulb state"); 	
	
	var summoningCell = getCell();
	moveToward(enemyID, 1);
	summon(CHIP_PUNY_BULB, summoningCell, stateMachine);

	etat = ACTION_CHOICE;
}

function moveTowardLeekFunction(){
	debug("move toward leek state"); 	

	moveToward(ourLeekID);

	etat = ACTION_CHOICE;	
}

function moveToWeaponRangeFunction(){
	debug("move to weapon range state"); 	

	moveTowardCell(canUseIfMoving((weaponID),  getCell(enemyID),  getLeek(), true,  false));

	etat = ACTION_CHOICE;
}

function moveToLightningRangeFunction(){
	debug("move to lightning range state"); 	

	moveTowardCell(canUseIfMoving(CHIP_LIGHTNING,  getCell(enemyID),  getLeek(), true,  false));

	etat = ACTION_CHOICE;
}

function moveToStalactiteRangeFunction(){
	debug("move to stalactite range state"); 	

	moveTowardCell(canUseIfMoving(CHIP_STALACTITE,  getCell(enemyID),  getLeek(), true,  false));

	etat = ACTION_CHOICE;

}

function moveToSparkRangeFunction(){
	debug("move to spark range state"); 	

	moveTowardCell(canUseIfMoving(CHIP_SPARK,  getCell(enemyID),  getLeek(), true,  false));

	etat = ACTION_CHOICE;

}

function moveToHelmetRangeFunction(){
	debug("move to helmet range state"); 	

	moveTowardCell(canUseIfMoving(CHIP_HELMET,  ourLeekID,  getLeek(), true,  false));

	etat = ACTION_CHOICE;
}

function useWeaponFunction(){
	debug("use weapon state"); 	

	useWeapon(enemyID);

	etat = ACTION_CHOICE;	
}

function useBandageFunction(){
	debug("use bandage state");

	useChip(CHIP_BANDAGE, ourLeekID);

	etat = ACTION_CHOICE;	
}

function useStalactiteFunction(){
	debug("use stalactite state");

	useChip(CHIP_STALACTITE, enemyID);

	etat = ACTION_CHOICE;
}

function useRockFunction(){
	debug("use rock state");

	useChip(CHIP_ROCK, enemyID);

	etat = ACTION_CHOICE;
}

function usePebbleFunction(){
	debug("use pebble state");

	useChip(CHIP_PEBBLE, enemyID);

	etat = ACTION_CHOICE;
}


function useHelmetFunction(){
	debug("use helmet state");

	useChip(CHIP_HELMET, ourLeekID);

	etat = ACTION_CHOICE;
}

function useShieldFunction(){
	debug("use SHIELD state");

	useChip(CHIP_SHIELD, ourLeekID);

	etat = ACTION_CHOICE;
}

function useFortressFunction(){
	debug("use fortress state");

	useChip(CHIP_FORTRESS, ourLeekID);

	etat = ACTION_CHOICE;
}

function useRampartFunction(){
	debug("use rampart state");

	useChip(CHIP_RAMPART, ourLeekID);

	etat = ACTION_CHOICE;
}

function useProteinFunction(){
	debug("use protein state");

	useChip(CHIP_PROTEIN, ourLeekID);

	etat = ACTION_CHOICE;
}

function useSparkFunction(){
	debug("use spark state");

	useChip(CHIP_SPARK, enemyID);

	etat = ACTION_CHOICE;
}

function useLightningFunction(){
	debug("use lightning state");

	useChip(CHIP_LIGHTNING, enemyID);

	etat = ACTION_CHOICE;
}

function useArmoringFunction(){
	debug("use armoring state");

	useChip(CHIP_ARMORING, ourLeekID);

	etat = ACTION_CHOICE;
}

function useArmorFunction(){
	debug("use armor state");

	useChip(CHIP_ARMOR, ourLeekID);

	etat = ACTION_CHOICE;
}

function useRegenerationFunction(){
	debug("use regeneration state");

	useChip(CHIP_REGENERATION, ourLeekID);

	etat = ACTION_CHOICE;
}


function useObjectFunction(){
	// Parameters of this state
	// actionSequence[0][0] =  USE_OBJECT;
	// actionSequence[0][1] =  object_ID; 
	// actionSequence[0][2] =  targetCell;

	debug("use object state : " + actionSequence[currentAction - 1][1]);

	if (isWeapon(actionSequence[currentAction - 1][1])){
		useWeaponOnCell(actionSequence[currentAction - 1][2]);
	}
	else if (isChip(actionSequence[currentAction - 1][1])){
		useChipOnCell(actionSequence[currentAction - 1][1], actionSequence[currentAction - 1][2]);
	}
	else{
		debug("error : this is not an object");
	}

	etat = ACTION_CHOICE;
}


function moveToCellFunction(){
	// Parameters of this state
	// actionSequence[0][0] =  USE_OBJECT;
	// actionSequence[0][1] =  cell; 
	
	debug("Move to cell state : ");
	moveTowardCell(actionSequence[currentAction - 1][1]);

	etat = ACTION_CHOICE;
}



function lastActionFunction() {

	debug("Total operation : " + getOperations());
	debug("remaining operation : " + (OPERATIONS_LIMIT - getOperations()));

	if (isDead(enemyID)){say ("Reviens gamin !! C'était pour rire ");}
	else if (getTurn() == 2){
		if (getType() == ENTITY_LEEK){
			say("Une larme de gin. Une rivière de tonic... Et ensuite la p'tite victime");
		}
		else {
			say("Pigeon, oiseau à la grise robe, dans l'enfer des villes, à mon regard tu te dérobes...Tu es vraiment le plus agile. ");
		}
	}

	etat = END_TURN;
}

